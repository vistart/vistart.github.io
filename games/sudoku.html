<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ•°ç‹¬æ¸¸æˆ</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .sudoku-cell {
      width: 48px;
      height: 48px;
      font-size: 1.25rem;
      font-weight: bold;
    }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-8">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-4xl font-bold text-center mb-8 text-indigo-900">æ•°ç‹¬æ¸¸æˆ</h1>
    
    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div>
          <h3 class="font-semibold mb-2 text-gray-700">é€‰æ‹©éš¾åº¦ï¼š</h3>
          <div class="flex gap-2">
            <button onclick="generateGame(1)" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition">ç®€æ˜“</button>
            <button onclick="generateGame(2)" class="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600 transition">ä¸­ç­‰</button>
            <button onclick="generateGame(3)" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition">å›°éš¾</button>
          </div>
        </div>
        
        <div>
          <h3 class="font-semibold mb-2 text-gray-700">å½“å‰éšæœºæ•°ï¼š</h3>
          <div class="flex gap-2">
            <input type="text" id="seedInput" class="flex-1 px-3 py-2 border rounded focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="è¾“å…¥7ä½éšæœºæ•°">
            <button onclick="loadFromSeed()" class="px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 transition">åŠ è½½</button>
          </div>
        </div>
      </div>
      
      <div class="mb-4">
        <button onclick="toggleCustomMode()" class="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 transition">è‡ªå®šä¹‰å±€é¢</button>
      </div>
      
      <div id="customPanel" class="mb-4 p-4 bg-gray-50 rounded hidden">
        <h3 class="font-semibold mb-2 text-gray-700">è¾“å…¥æ•°ç‹¬ï¼ˆ0è¡¨ç¤ºç©ºæ ¼ï¼Œæ¯è¡Œ9ä¸ªæ•°å­—ï¼Œç”¨ç©ºæ ¼åˆ†éš”ï¼‰ï¼š</h3>
        <textarea id="customInput" class="w-full h-32 px-3 py-2 border rounded font-mono text-sm focus:outline-none focus:ring-2 focus:ring-purple-500" placeholder="ä¾‹å¦‚ï¼š&#10;5 3 0 0 7 0 0 0 0&#10;6 0 0 1 9 5 0 0 0&#10;..."></textarea>
        <button onclick="loadCustomPuzzle()" class="mt-2 px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 transition">åŠ è½½è‡ªå®šä¹‰</button>
      </div>
      
      <div id="message" class="mb-4 p-3 rounded hidden"></div>
      
      <div class="flex gap-2">
        <button onclick="reset()" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition">é‡ç½®</button>
        <button onclick="toggleSolution()" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition">æ˜¾ç¤ºç­”æ¡ˆ</button>
        <button onclick="checkSolution()" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition">æ£€æŸ¥ç­”æ¡ˆ</button>
      </div>
    </div>
    
    <!-- æ•°ç‹¬ç½‘æ ¼ -->
    <div class="bg-white rounded-lg shadow-lg p-6">
      <div id="sudokuGrid" class="inline-block border-4 border-gray-800"></div>
      <div class="mt-4 text-sm text-gray-600">
        <p>æç¤ºï¼šç°è‰²æ•°å­—ä¸ºåˆå§‹æ•°å­—ï¼Œè“è‰²æ•°å­—ä¸ºä½ å¡«å†™çš„æ•°å­—</p>
        <p id="solutionHint" class="text-yellow-600 hidden">é»„è‰²èƒŒæ™¯æ˜¾ç¤ºçš„æ˜¯ç­”æ¡ˆ</p>
      </div>
    </div>
    
    <div id="emptyState" class="bg-white rounded-lg shadow-lg p-12 text-center text-gray-500">
      <p class="text-xl">è¯·é€‰æ‹©éš¾åº¦å¼€å§‹æ¸¸æˆï¼Œæˆ–åŠ è½½è‡ªå®šä¹‰å±€é¢</p>
    </div>
  </div>

  <script>
    // å…¨å±€çŠ¶æ€
    let puzzle = null;
    let userBoard = null;
    let solution = null;
    let showSolution = false;
    let seedCode = '';

    // æ•°ç‹¬æ±‚è§£å™¨ï¼ˆå›æº¯ç®—æ³•ï¼‰
    function solveSudoku(board) {
      const newBoard = board.map(row => [...row]);
      
      const isValid = (row, col, num) => {
        for (let x = 0; x < 9; x++) {
          if (newBoard[row][x] === num) return false;
        }
        for (let x = 0; x < 9; x++) {
          if (newBoard[x][col] === num) return false;
        }
        const startRow = Math.floor(row / 3) * 3;
        const startCol = Math.floor(col / 3) * 3;
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            if (newBoard[startRow + i][startCol + j] === num) return false;
          }
        }
        return true;
      };
      
      const solve = () => {
        for (let row = 0; row < 9; row++) {
          for (let col = 0; col < 9; col++) {
            if (newBoard[row][col] === 0) {
              for (let num = 1; num <= 9; num++) {
                if (isValid(row, col, num)) {
                  newBoard[row][col] = num;
                  if (solve()) return true;
                  newBoard[row][col] = 0;
                }
              }
              return false;
            }
          }
        }
        return true;
      };
      
      solve();
      return newBoard;
    }

    // æ£€æŸ¥æ•°ç‹¬æ˜¯å¦æœ‰æ•ˆ
    function isValidSudoku(board) {
      for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
          if (board[row][col] !== 0) {
            const num = board[row][col];
            board[row][col] = 0;
            
            const isValid = (r, c, n) => {
              for (let x = 0; x < 9; x++) {
                if (x !== c && board[r][x] === n) return false;
                if (x !== r && board[x][c] === n) return false;
              }
              const startRow = Math.floor(r / 3) * 3;
              const startCol = Math.floor(c / 3) * 3;
              for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                  const nr = startRow + i;
                  const nc = startCol + j;
                  if (nr !== r && nc !== c && board[nr][nc] === n) return false;
                }
              }
              return true;
            };
            
            if (!isValid(row, col, num)) {
              board[row][col] = num;
              return false;
            }
            board[row][col] = num;
          }
        }
      }
      return true;
    }

    // ç”Ÿæˆå®Œæ•´çš„æ•°ç‹¬
    function generateFullSudoku(seed) {
      const board = Array(9).fill(0).map(() => Array(9).fill(0));
      
      let random = seed;
      const nextRandom = () => {
        random = (random * 9301 + 49297) % 233280;
        return random / 233280;
      };
      
      const isValid = (row, col, num) => {
        for (let x = 0; x < 9; x++) {
          if (board[row][x] === num || board[x][col] === num) return false;
        }
        const startRow = Math.floor(row / 3) * 3;
        const startCol = Math.floor(col / 3) * 3;
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            if (board[startRow + i][startCol + j] === num) return false;
          }
        }
        return true;
      };
      
      const fill = (row, col) => {
        if (row === 9) return true;
        if (col === 9) return fill(row + 1, 0);
        
        const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        for (let i = nums.length - 1; i > 0; i--) {
          const j = Math.floor(nextRandom() * (i + 1));
          [nums[i], nums[j]] = [nums[j], nums[i]];
        }
        
        for (const num of nums) {
          if (isValid(row, col, num)) {
            board[row][col] = num;
            if (fill(row, col + 1)) return true;
            board[row][col] = 0;
          }
        }
        return false;
      };
      
      fill(0, 0);
      return board;
    }

    // æ ¹æ®éš¾åº¦æŒ–ç©º
    function createPuzzle(fullBoard, difficulty, seed) {
      const puzzleBoard = fullBoard.map(row => [...row]);
      
      let cellsToRemove;
      if (difficulty === 1) cellsToRemove = 35;
      else if (difficulty === 2) cellsToRemove = 45;
      else cellsToRemove = 55;
      
      let random = seed;
      const nextRandom = () => {
        random = (random * 9301 + 49297) % 233280;
        return random / 233280;
      };
      
      const positions = [];
      for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
          positions.push([i, j]);
        }
      }
      
      for (let i = positions.length - 1; i > 0; i--) {
        const j = Math.floor(nextRandom() * (i + 1));
        [positions[i], positions[j]] = [positions[j], positions[i]];
      }
      
      for (let i = 0; i < cellsToRemove && i < positions.length; i++) {
        const [row, col] = positions[i];
        puzzleBoard[row][col] = 0;
      }
      
      return puzzleBoard;
    }

    // ç”Ÿæˆæ¸¸æˆ
    function generateGame(difficulty) {
      const randomValue = Math.floor(Math.random() * 1000000);
      const seed = difficulty * 1000000 + randomValue;
      const code = `${difficulty}${randomValue.toString().padStart(6, '0')}`;
      
      const fullBoard = generateFullSudoku(seed);
      const puzzleBoard = createPuzzle(fullBoard, difficulty, seed + 1);
      
      puzzle = puzzleBoard;
      userBoard = puzzleBoard.map(row => [...row]);
      solution = solveSudoku(puzzleBoard);
      showSolution = false;
      seedCode = code;
      
      document.getElementById('seedInput').value = code;
      showMessage('');
      renderSudoku();
    }

    // ä»éšæœºæ•°åŠ è½½
    function loadFromSeed() {
      const input = document.getElementById('seedInput').value;
      if (input.length !== 7) {
        showMessage('éšæœºæ•°æ ¼å¼é”™è¯¯ï¼åº”ä¸º7ä½æ•°å­—', 'error');
        return;
      }
      
      const difficulty = parseInt(input[0]);
      if (difficulty < 1 || difficulty > 3) {
        showMessage('éš¾åº¦æŒ‡æ ‡é”™è¯¯ï¼åº”ä¸º1-3', 'error');
        return;
      }
      
      const randomValue = parseInt(input.slice(1));
      const seed = difficulty * 1000000 + randomValue;
      
      const fullBoard = generateFullSudoku(seed);
      const puzzleBoard = createPuzzle(fullBoard, difficulty, seed + 1);
      
      puzzle = puzzleBoard;
      userBoard = puzzleBoard.map(row => [...row]);
      solution = solveSudoku(puzzleBoard);
      showSolution = false;
      seedCode = input;
      
      showMessage('æˆåŠŸåŠ è½½æ•°ç‹¬ï¼', 'success');
      renderSudoku();
    }

    // åŠ è½½è‡ªå®šä¹‰å±€é¢
    function loadCustomPuzzle() {
      try {
        const input = document.getElementById('customInput').value;
        const lines = input.trim().split('\n');
        if (lines.length !== 9) {
          showMessage('è¾“å…¥é”™è¯¯ï¼åº”ä¸º9è¡Œ', 'error');
          return;
        }
        
        const board = lines.map(line => {
          const nums = line.trim().split(/\s+/).map(n => parseInt(n) || 0);
          if (nums.length !== 9) {
            throw new Error('æ¯è¡Œåº”æœ‰9ä¸ªæ•°å­—');
          }
          return nums;
        });
        
        if (!isValidSudoku(board)) {
          showMessage('æ•°ç‹¬å±€é¢ä¸åˆæ³•ï¼å­˜åœ¨å†²çª', 'error');
          return;
        }
        
        const solved = solveSudoku(board);
        const hasEmptyCells = board.some(row => row.includes(0));
        if (!hasEmptyCells) {
          showMessage('å·²æ˜¯å®Œæ•´æ•°ç‹¬ï¼', 'error');
          return;
        }
        
        puzzle = board;
        userBoard = board.map(row => [...row]);
        solution = solved;
        showSolution = false;
        seedCode = 'è‡ªå®šä¹‰';
        
        document.getElementById('seedInput').value = 'è‡ªå®šä¹‰';
        showMessage('è‡ªå®šä¹‰æ•°ç‹¬åŠ è½½æˆåŠŸï¼', 'success');
        renderSudoku();
      } catch (err) {
        showMessage(`åŠ è½½å¤±è´¥ï¼š${err.message}`, 'error');
      }
    }

    // åˆ‡æ¢è‡ªå®šä¹‰æ¨¡å¼
    function toggleCustomMode() {
      const panel = document.getElementById('customPanel');
      panel.classList.toggle('hidden');
    }

    // æ˜¾ç¤ºæ¶ˆæ¯
    function showMessage(msg, type = '') {
      const msgEl = document.getElementById('message');
      if (!msg) {
        msgEl.classList.add('hidden');
        return;
      }
      
      msgEl.textContent = msg;
      msgEl.classList.remove('hidden', 'bg-green-100', 'text-green-800', 'bg-red-100', 'text-red-800');
      
      if (type === 'success' || msg.includes('æˆåŠŸ') || msg.includes('æ­å–œ')) {
        msgEl.classList.add('bg-green-100', 'text-green-800');
      } else if (type === 'error') {
        msgEl.classList.add('bg-red-100', 'text-red-800');
      }
    }

    // å¤„ç†å•å…ƒæ ¼å˜åŒ–
    function handleCellChange(row, col, value) {
      if (puzzle[row][col] !== 0) return;
      
      const num = parseInt(value) || 0;
      userBoard[row][col] = num >= 0 && num <= 9 ? num : 0;
      renderSudoku();
    }

    // æ¸²æŸ“æ•°ç‹¬
    function renderSudoku() {
      const grid = document.getElementById('sudokuGrid');
      const emptyState = document.getElementById('emptyState');
      
      if (!userBoard) {
        grid.innerHTML = '';
        emptyState.classList.remove('hidden');
        return;
      }
      
      emptyState.classList.add('hidden');
      grid.innerHTML = '';
      
      userBoard.forEach((row, rowIndex) => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'flex';
        
        row.forEach((cell, colIndex) => {
          const isInitial = puzzle[rowIndex][colIndex] !== 0;
          const isCorrect = showSolution && solution && cell === solution[rowIndex][colIndex];
          const isWrong = showSolution && solution && cell !== 0 && cell !== solution[rowIndex][colIndex];
          const showAnswer = showSolution && cell === 0 && solution;
          
          const input = document.createElement('input');
          input.type = 'text';
          input.maxLength = 1;
          input.value = showAnswer ? solution[rowIndex][colIndex] : (cell === 0 ? '' : cell);
          input.className = 'sudoku-cell text-center border focus:outline-none focus:ring-2 focus:ring-indigo-500';
          
          // è¾¹æ¡†æ ·å¼
          if (colIndex % 3 === 2 && colIndex !== 8) {
            input.classList.add('border-r-2', 'border-r-gray-800');
          } else {
            input.classList.add('border-r', 'border-r-gray-300');
          }
          if (rowIndex % 3 === 2 && rowIndex !== 8) {
            input.classList.add('border-b-2', 'border-b-gray-800');
          } else {
            input.classList.add('border-b', 'border-b-gray-300');
          }
          
          // èƒŒæ™¯å’Œæ–‡å­—é¢œè‰²
          if (isInitial) {
            input.classList.add('bg-gray-200', 'text-gray-900', 'cursor-not-allowed');
            input.readOnly = true;
          } else if (showAnswer) {
            input.classList.add('bg-yellow-100', 'text-gray-500');
            input.readOnly = true;
          } else {
            input.classList.add('bg-white', 'text-blue-600');
          }
          
          if (isCorrect) input.classList.add('bg-green-100');
          if (isWrong) input.classList.add('bg-red-100');
          
          if (!isInitial && !showAnswer) {
            input.addEventListener('input', (e) => {
              handleCellChange(rowIndex, colIndex, e.target.value);
            });
          }
          
          rowDiv.appendChild(input);
        });
        
        grid.appendChild(rowDiv);
      });
      
      document.getElementById('solutionHint').classList.toggle('hidden', !showSolution);
    }

    // åˆ‡æ¢æ˜¾ç¤ºç­”æ¡ˆ
    function toggleSolution() {
      if (!userBoard) return;
      showSolution = !showSolution;
      const btn = event.target;
      btn.textContent = showSolution ? 'éšè—ç­”æ¡ˆ' : 'æ˜¾ç¤ºç­”æ¡ˆ';
      renderSudoku();
    }

    // æ£€æŸ¥ç­”æ¡ˆ
    function checkSolution() {
      if (!userBoard) return;
      
      const isComplete = !userBoard.some(row => row.includes(0));
      if (!isComplete) {
        showMessage('è¿˜æœ‰ç©ºæ ¼æœªå¡«ï¼', 'error');
        return;
      }
      
      const isCorrect = JSON.stringify(userBoard) === JSON.stringify(solution);
      showMessage(isCorrect ? 'ğŸ‰ æ­å–œï¼ç­”æ¡ˆå®Œå…¨æ­£ç¡®ï¼' : 'âŒ ç­”æ¡ˆæœ‰è¯¯ï¼Œè¯·æ£€æŸ¥', isCorrect ? 'success' : 'error');
    }

    // é‡ç½®
    function reset() {
      if (!puzzle) return;
      userBoard = puzzle.map(row => [...row]);
      showSolution = false;
      const btn = document.querySelector('button[onclick="toggleSolution()"]');
      if (btn) btn.textContent = 'æ˜¾ç¤ºç­”æ¡ˆ';
      showMessage('');
      renderSudoku();
    }

    // åˆå§‹åŒ–
    renderSudoku();
  </script>
</body>
</html>