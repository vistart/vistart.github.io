<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>中国象棋</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Noto Serif SC', 'KaiTi', 'STKaiti', serif;
            -webkit-font-smoothing: antialiased;
            overflow-x: hidden;
        }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1a0e05; }
        ::-webkit-scrollbar-thumb { background: #8B6914; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #b8862a; }
        button:focus-visible { outline: 2px solid #c62828; outline-offset: 2px; }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // ─── Constants ───
        const COLS = 9, ROWS = 10, RED = "red", BLACK = "black";
        const PIECE_NAMES = {
            K:{red:"帥",black:"將"}, A:{red:"仕",black:"士"}, B:{red:"相",black:"象"},
            N:{red:"馬",black:"马"}, R:{red:"車",black:"车"}, C:{red:"炮",black:"砲"}, P:{red:"兵",black:"卒"},
        };
        const PIECE_MAX = {K:1,A:2,B:2,N:2,R:2,C:2,P:5};
        const ALL_PIECE_TYPES = ["K","A","B","N","R","C","P"];
        const CN_NUM = ["","一","二","三","四","五","六","七","八","九"];

        // ─── FEN Serialization ───
        function boardToFen(board, turn) {
            let fen = "";
            for (let r = 0; r < ROWS; r++) {
                let empty = 0;
                for (let c = 0; c < COLS; c++) {
                    const p = board[r][c];
                    if (!p) { empty++; continue; }
                    if (empty > 0) { fen += empty; empty = 0; }
                    fen += p.side === RED ? p.type : p.type.toLowerCase();
                }
                if (empty > 0) fen += empty;
                if (r < ROWS - 1) fen += "/";
            }
            return fen + " " + (turn === RED ? "w" : "b");
        }

        function fenToBoard(fen) {
            try {
                const parts = fen.trim().split(/\s+/);
                const rows = parts[0].split("/");
                const turn = parts[1] === "b" ? BLACK : RED;
                const board = emptyBoard();
                for (let r = 0; r < Math.min(rows.length, ROWS); r++) {
                    let c = 0;
                    for (const ch of rows[r]) {
                        if (ch >= "1" && ch <= "9") { c += parseInt(ch); continue; }
                        const upper = ch.toUpperCase();
                        if ("KABNRCP".includes(upper)) {
                            board[r][c] = { type: upper, side: ch === upper ? RED : BLACK };
                            c++;
                        }
                    }
                }
                return { board, turn };
            } catch (e) { return null; }
        }

        function exportEndgame(name, board, turn) {
            return JSON.stringify({ name, fen: boardToFen(board, turn), version: 1 });
        }

        function importEndgame(str) {
            try {
                const obj = JSON.parse(str);
                if (!obj.fen) return null;
                const result = fenToBoard(obj.fen);
                if (!result) return null;
                return { name: obj.name || "未命名残局", board: result.board, turn: result.turn };
            } catch (e) {
                const result = fenToBoard(str);
                if (!result) return null;
                return { name: "导入残局", board: result.board, turn: result.turn };
            }
        }

        // ─── Classic Endgames ───
        const CLASSIC_ENDGAMES = [
            { name:"七星聚会", desc:"四大名局之首。红黑各七子，棋路深远，变化极为复杂。",
                fen:"2bakab2/9/4c4/p3C3p/2p1c1p2/2P1p1P2/P3C3P/4B4/9/2BAKAB2 w" },
            { name:"蚯蚓降龙", desc:"四大名局之一。以兵卒为主力，蚯蚓虽小，可降神龙。",
                fen:"4kab2/4a4/4b4/3R4p/8P/4p4/4r4/4B4/4A4/2B1KA3 w" },
            { name:"野马操田", desc:"四大名局之一。马在田间纵横驰骋，棋势奔放。",
                fen:"3k1ab2/4a4/4b4/9/1N2P4/9/2n6/4BA3/4A4/3K1B3 w" },
            { name:"千里独行", desc:"四大名局之一。孤車深入敌境，纵横千里。红先胜。",
                fen:"3aka3/9/4b2b1/p3p3p/9/9/9/4R4/9/4K4 w" },
            { name:"大九连环", desc:"著名古谱排局，环环相扣，九曲回肠。",
                fen:"2bak4/4a4/2N1b4/CR1Pp4/9/2p1p4/cr2P4/9/4n4/4K4 w" },
            { name:"小征东", desc:"经典征伐残局，红方以少胜多，步步紧逼。",
                fen:"3aka3/9/3aN4/9/2b5R/9/9/3AB4/4A4/4K4 w" },
            { name:"火烧连营", desc:"连续攻杀，势如燎原之火，烧尽敌营。",
                fen:"3ak4/4a4/4b4/4R3C/9/9/4r4/4B4/4A4/3AK4 w" },
            { name:"炮打两狼关", desc:"炮镇中路，左右开弓，轰击敌阵两翼。",
                fen:"3ak1b2/4a4/4b4/4C4/4P4/9/9/4B4/4A4/3AK4 w" },
            { name:"征西", desc:"经典古谱残局，红方挥师西征，势不可挡。",
                fen:"2b1ka3/4a4/4b4/C8/4P4/3c5/9/9/4Ap3/3AK4 w" },
        ];

        // ─── Notation helpers ───
        function colToNum(col, side) { return side === RED ? 9 - col : col + 1; }
        function numStr(n, side) { return side === RED ? CN_NUM[n] : String(n); }
        function sortFTB(rows, side) { return [...rows].sort((a, b) => side === RED ? a - b : b - a); }

        function formatMove(bd, fr, fc, tr, tc) {
            const piece = bd[fr][fc], { type, side } = piece;
            const name = PIECE_NAMES[type][side];
            const fCol = colToNum(fc, side), tCol = colToNum(tc, side);
            const isFwd = side === RED ? tr < fr : tr > fr, isH = tr === fr;
            let act, dst;
            if (isH) { act = "平"; dst = numStr(tCol, side); }
            else { act = isFwd ? "进" : "退"; const st = ["R","C","K","P"].includes(type) && fc === tc; dst = st ? numStr(Math.abs(tr - fr), side) : numStr(tCol, side); }
            let pfx;
            if (type === "A" || type === "B" || type === "K") { pfx = name + numStr(fCol, side); return { text: pfx + act + dst, side }; }
            if (type !== "P") {
                const sc = []; for (let r = 0; r < ROWS; r++) if (bd[r][fc]?.type === type && bd[r][fc]?.side === side) sc.push(r);
                if (sc.length >= 2) { const s = sortFTB(sc, side); pfx = (fr === s[0] ? "前" : "后") + name; } else pfx = name + numStr(fCol, side);
                return { text: pfx + act + dst, side };
            }
            const pbc = {}; for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) if (bd[r][c]?.type === "P" && bd[r][c]?.side === side) { if (!pbc[c]) pbc[c] = []; pbc[c].push(r); }
            const mc = Object.keys(pbc).filter(c => pbc[c].length >= 2).map(Number);
            if (!mc.includes(fc)) { pfx = name + numStr(fCol, side); return { text: pfx + act + dst, side }; }
            if (mc.length === 1) {
                const rows = sortFTB(pbc[mc[0]], side), idx = rows.indexOf(fr), n = rows.length;
                if (n === 2) pfx = (idx === 0 ? "前" : "后") + name;
                else if (n === 3) pfx = (idx === 0 ? "前" : idx === 1 ? "中" : "后") + name;
                else { pfx = ["前","二","三","四","五"][idx] + name; }
                return { text: pfx + act + dst, side };
            }
            let all = []; for (const col of mc) for (const row of pbc[col]) all.push({ r: row, c: col });
            all.sort((a, b) => { const ca = colToNum(a.c, side), cb = colToNum(b.c, side); return ca !== cb ? ca - cb : (side === RED ? a.r - b.r : b.r - a.r); });
            pfx = ["一","二","三","四","五"][all.findIndex(p => p.r === fr && p.c === fc)] + name;
            return { text: pfx + act + dst, side };
        }

        // ─── Board helpers ───
        function emptyBoard() { return Array.from({length:ROWS},()=>Array(COLS).fill(null)); }
        function cloneBoard(b) { return b.map(row=>row.map(c=>c?{...c}:null)); }
        function createStandardBoard() {
            const b=emptyBoard(), bk=["R","N","B","A","K","A","B","N","R"];
            bk.forEach((t,c)=>(b[0][c]={type:t,side:BLACK})); b[2][1]={type:"C",side:BLACK}; b[2][7]={type:"C",side:BLACK};
            [0,2,4,6,8].forEach(c=>(b[3][c]={type:"P",side:BLACK}));
            bk.forEach((t,c)=>(b[9][c]={type:t,side:RED})); b[7][1]={type:"C",side:RED}; b[7][7]={type:"C",side:RED};
            [0,2,4,6,8].forEach(c=>(b[6][c]={type:"P",side:RED})); return b;
        }

        // ─── Move Validation ───
        function inBounds(r,c){return r>=0&&r<ROWS&&c>=0&&c<COLS;}
        function inPalace(r,c,side){if(c<3||c>5)return false;return side===RED?r>=7&&r<=9:r>=0&&r<=2;}
        function getRawMoves(board,r,c){const piece=board[r][c];if(!piece)return[];const{type,side}=piece;const moves=[];const dir=side===RED?-1:1;switch(type){case "K":[[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr,dc])=>{const nr=r+dr,nc=c+dc;if(inBounds(nr,nc)&&inPalace(nr,nc,side))moves.push([nr,nc]);});{const od=side===RED?-1:1;let tr=r+od;while(inBounds(tr,c)){if(board[tr][c]){if(board[tr][c].type==="K"&&board[tr][c].side!==side)moves.push([tr,c]);break;}tr+=od;}}break;case "A":[[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc])=>{const nr=r+dr,nc=c+dc;if(inBounds(nr,nc)&&inPalace(nr,nc,side))moves.push([nr,nc]);});break;case "B":[[2,2],[2,-2],[-2,2],[-2,-2]].forEach(([dr,dc])=>{const nr=r+dr,nc=c+dc,er=r+dr/2,ec=c+dc/2;if(!inBounds(nr,nc))return;if(side===RED&&nr<5)return;if(side===BLACK&&nr>4)return;if(board[er][ec])return;moves.push([nr,nc]);});break;case "N":[[[-1,0],[-2,-1]],[[-1,0],[-2,1]],[[1,0],[2,-1]],[[1,0],[2,1]],[[0,-1],[-1,-2]],[[0,-1],[1,-2]],[[0,1],[-1,2]],[[0,1],[1,2]]].forEach(([[lr,lc],[dr,dc]])=>{const nr=r+dr,nc=c+dc;if(!inBounds(nr,nc)||board[r+lr][c+lc])return;moves.push([nr,nc]);});break;case "R":for(const[dr,dc]of[[0,1],[0,-1],[1,0],[-1,0]]){let nr=r+dr,nc=c+dc;while(inBounds(nr,nc)){if(board[nr][nc]){moves.push([nr,nc]);break;}moves.push([nr,nc]);nr+=dr;nc+=dc;}}break;case "C":for(const[dr,dc]of[[0,1],[0,-1],[1,0],[-1,0]]){let nr=r+dr,nc=c+dc,jumped=false;while(inBounds(nr,nc)){if(!jumped){if(board[nr][nc])jumped=true;else moves.push([nr,nc]);}else{if(board[nr][nc]){moves.push([nr,nc]);break;}}nr+=dr;nc+=dc;}}break;case "P":moves.push([r+dir,c]);if((side===RED&&r<=4)||(side===BLACK&&r>=5)){moves.push([r,c-1]);moves.push([r,c+1]);}break;}return moves.filter(([mr,mc])=>inBounds(mr,mc)&&(!board[mr][mc]||board[mr][mc].side!==side));}
        function findKing(board,side){for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(board[r][c]?.type==="K"&&board[r][c]?.side===side)return[r,c];return null;}
        function isInCheck(board,side){const kp=findKing(board,side);if(!kp)return true;const enemy=side===RED?BLACK:RED;for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(board[r][c]?.side===enemy&&getRawMoves(board,r,c).some(([mr,mc])=>mr===kp[0]&&mc===kp[1]))return true;return false;}
        function getValidMoves(board,r,c){const piece=board[r][c];if(!piece)return[];return getRawMoves(board,r,c).filter(([mr,mc])=>{const nb=board.map(row=>row.slice());nb[mr][mc]=nb[r][c];nb[r][c]=null;return !isInCheck(nb,piece.side);});}
        function hasAnyMoves(board,side){for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(board[r][c]?.side===side&&getValidMoves(board,r,c).length>0)return true;return false;}
        function fmtTime(s){return `${Math.floor(s/60).toString().padStart(2,"0")}:${(s%60).toString().padStart(2,"0")}`;}
        function countOnBoard(board,type,side){let n=0;for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(board[r][c]?.type===type&&board[r][c]?.side===side)n++;return n;}
        function isValidPlacement(type,side,r,c){if(type==="K")return inPalace(r,c,side);if(type==="A"){const vp=side===RED?[[9,3],[9,5],[8,4],[7,3],[7,5]]:[[0,3],[0,5],[1,4],[2,3],[2,5]];return vp.some(([vr,vc])=>vr===r&&vc===c);}if(type==="B"){if(side===RED&&r<5)return false;if(side===BLACK&&r>4)return false;const vp=side===RED?[[9,2],[9,6],[7,0],[7,4],[7,8],[5,2],[5,6]]:[[0,2],[0,6],[2,0],[2,4],[2,8],[4,2],[4,6]];return vp.some(([vr,vc])=>vr===r&&vc===c);}return true;}

        // ─── Dimensions ───
        const CELL=54,BOARD_W=CELL*8,BOARD_H=CELL*9,PAD_X=34,PAD_TOP=48,PAD_BOT=48;
        const SVG_W=BOARD_W+PAD_X*2,SVG_H=BOARD_H+PAD_TOP+PAD_BOT;
        const FONT="'Noto Serif SC','KaiTi','STKaiti',serif";
        const RED_COL_LABELS=["九","八","七","六","五","四","三","二","一"];
        const BLACK_COL_LABELS=["1","2","3","4","5","6","7","8","9"];

        // ─── Styles ───
        const ST={
            menuRoot:{minHeight:"100vh",display:"flex",alignItems:"center",justifyContent:"center",background:"linear-gradient(160deg,#1a0e05 0%,#2c1a0e 40%,#1a0e05 100%)",fontFamily:FONT,padding:20},
            menuBox:{background:"linear-gradient(170deg,#f5e6c8,#eedbb0)",borderRadius:16,padding:"40px 36px",maxWidth:520,width:"100%",boxShadow:"0 20px 60px rgba(0,0,0,0.5),inset 0 1px 0 rgba(255,255,255,0.3)",border:"2px solid #b8862a"},
            menuDecor:{width:60,height:3,background:"#8B4513",margin:"0 auto 20px",borderRadius:2},
            menuTitle:{textAlign:"center",fontSize:42,fontWeight:900,color:"#4a2c0a",letterSpacing:12,margin:0,textShadow:"1px 1px 0 rgba(255,255,255,0.3)"},
            menuSub:{textAlign:"center",fontSize:18,color:"#8B6914",letterSpacing:20,margin:"8px 0 0"},
            menuLine:{width:"80%",height:1,background:"linear-gradient(90deg,transparent,#8B6914,transparent)",margin:"24px auto"},
            menuPri:{display:"flex",alignItems:"center",gap:14,width:"100%",padding:"16px 20px",background:"linear-gradient(135deg,#c62828,#b71c1c)",color:"#fff",border:"none",borderRadius:10,cursor:"pointer",fontSize:16,fontFamily:FONT,textAlign:"left",boxShadow:"0 4px 12px rgba(198,40,40,0.3)"},
            menuSec:{display:"flex",alignItems:"center",gap:14,width:"100%",padding:"16px 20px",background:"linear-gradient(135deg,#5d4037,#4e342e)",color:"#fff",border:"none",borderRadius:10,cursor:"pointer",fontSize:16,fontFamily:FONT,textAlign:"left",boxShadow:"0 4px 12px rgba(78,52,46,0.3)"},
            menuSec2:{display:"flex",alignItems:"center",gap:14,width:"100%",padding:"16px 20px",background:"linear-gradient(135deg,#33691e,#2e7d32)",color:"#fff",border:"none",borderRadius:10,cursor:"pointer",fontSize:16,fontFamily:FONT,textAlign:"left",boxShadow:"0 4px 12px rgba(46,125,50,0.3)"},
            menuIco:{fontSize:28,width:36,textAlign:"center",flexShrink:0},
            menuLbl:{fontSize:17,fontWeight:700,letterSpacing:2},
            menuDsc:{fontSize:13,opacity:0.85,marginTop:2},
            edRoot:{minHeight:"100vh",background:"linear-gradient(160deg,#1a0e05 0%,#2c1a0e 40%,#1a0e05 100%)",fontFamily:FONT,padding:"12px 16px",display:"flex",flexDirection:"column",alignItems:"center"},
            edHead:{display:"flex",alignItems:"center",justifyContent:"space-between",width:"100%",maxWidth:1100,marginBottom:12},
            edTitle:{color:"#e8c87a",fontSize:22,fontWeight:700,letterSpacing:4,margin:0},
            edBody:{display:"flex",gap:16,alignItems:"flex-start",flexWrap:"wrap",justifyContent:"center"},
            palette:{width:160,background:"rgba(245,230,200,0.95)",borderRadius:10,padding:"14px 12px",display:"flex",flexDirection:"column",gap:4},
            palTitle:{display:"flex",alignItems:"center",gap:8,fontSize:15,fontWeight:700,color:"#4a2c0a",marginBottom:4},
            palDot:{width:12,height:12,borderRadius:"50%"},
            palHelp:{fontSize:11,color:"#8B6914",marginBottom:8},
            palItem:{display:"flex",alignItems:"center",gap:8,padding:"7px 10px",borderRadius:8,background:"rgba(139,105,20,0.05)",border:"1px solid rgba(139,105,20,0.12)",userSelect:"none"},
            palCount:{fontSize:13,color:"#8B6914",marginLeft:"auto"},
            ctrlLabel:{fontSize:13,fontWeight:700,color:"#4a2c0a",marginBottom:6,letterSpacing:2},
            nameInput:{width:"100%",padding:"6px 8px",border:"1.5px solid #c4a35a",borderRadius:6,fontFamily:FONT,fontSize:14,color:"#4a2c0a",background:"rgba(255,255,255,0.5)",outline:"none",boxSizing:"border-box"},
            turnBtn:{flex:1,padding:"7px 0",border:"1.5px solid #c4a35a",borderRadius:6,background:"transparent",cursor:"pointer",fontFamily:FONT,fontSize:14,fontWeight:600,color:"#4a2c0a"},
            turnBtnR:{background:"linear-gradient(135deg,#c62828,#e53935)",color:"#fff",borderColor:"#c62828"},
            turnBtnB:{background:"linear-gradient(135deg,#212121,#424242)",color:"#fff",borderColor:"#333"},
            clearBtn:{padding:"7px 0",border:"1.5px solid #c4a35a",borderRadius:6,background:"transparent",cursor:"pointer",fontFamily:FONT,fontSize:13,color:"#8B6914",marginTop:2},
            errMsg:{fontSize:12,color:"#c62828",textAlign:"center",padding:"4px 0",fontWeight:600},
            startBtn:{padding:"10px 0",background:"linear-gradient(135deg,#c62828,#b71c1c)",color:"#fff",border:"none",borderRadius:8,cursor:"pointer",fontFamily:FONT,fontSize:16,fontWeight:700,letterSpacing:3,marginTop:4,boxShadow:"0 3px 10px rgba(198,40,40,0.3)"},
            edTip:{fontSize:11,color:"#8B6914",lineHeight:1.6,marginTop:10},
            importToggle:{width:"100%",padding:"7px 0",border:"1.5px dashed #c4a35a",borderRadius:6,background:"transparent",cursor:"pointer",fontFamily:FONT,fontSize:12,color:"#8B6914",marginTop:2},
            importBox:{background:"rgba(139,105,20,0.06)",border:"1px solid rgba(139,105,20,0.15)",borderRadius:6,padding:8,marginTop:4,display:"flex",flexDirection:"column",gap:4},
            importTextarea:{width:"100%",height:50,padding:6,border:"1px solid #c4a35a",borderRadius:4,fontFamily:"monospace",fontSize:11,resize:"vertical",boxSizing:"border-box",background:"rgba(255,255,255,0.6)"},
            importBtn:{padding:"5px 10px",border:"1px solid #c4a35a",borderRadius:4,background:"rgba(139,105,20,0.1)",cursor:"pointer",fontFamily:FONT,fontSize:11,color:"#4a2c0a"},
            overlay:{position:"fixed",inset:0,background:"rgba(0,0,0,0.6)",display:"flex",alignItems:"center",justifyContent:"center",zIndex:100,backdropFilter:"blur(4px)"},
            modalBox:{background:"linear-gradient(170deg,#f5e6c8,#eedbb0)",borderRadius:14,padding:"28px 32px",maxWidth:460,width:"90%",boxShadow:"0 12px 40px rgba(0,0,0,0.4)",border:"2px solid #b8862a"},
            modalTitle:{fontSize:20,fontWeight:700,color:"#4a2c0a",letterSpacing:3,textAlign:"center",marginBottom:12},
            modalHint:{fontSize:12,color:"#8B6914",marginBottom:8},
            modalTextarea:{width:"100%",height:80,padding:8,border:"1px solid #c4a35a",borderRadius:6,fontFamily:"monospace",fontSize:11,resize:"vertical",boxSizing:"border-box",background:"rgba(255,255,255,0.6)",color:"#333"},
            modalBtn:{padding:"8px 20px",background:"linear-gradient(135deg,#c62828,#b71c1c)",color:"#fff",border:"none",borderRadius:6,cursor:"pointer",fontFamily:FONT,fontSize:14,fontWeight:700,letterSpacing:2},
            modalBtnAlt:{background:"linear-gradient(135deg,#5d4037,#4e342e)"},
            ovBox:{background:"linear-gradient(170deg,#f5e6c8,#eedbb0)",borderRadius:14,padding:"32px 40px",textAlign:"center",boxShadow:"0 12px 40px rgba(0,0,0,0.4)",border:"2px solid #b8862a"},
            ovTitle:{fontSize:28,fontWeight:900,color:"#4a2c0a",letterSpacing:4,marginBottom:20},
            ovBtns:{display:"flex",gap:12,justifyContent:"center"},
            ovBtn:{padding:"10px 24px",background:"linear-gradient(135deg,#c62828,#b71c1c)",color:"#fff",border:"none",borderRadius:8,cursor:"pointer",fontSize:15,fontWeight:700,fontFamily:FONT,letterSpacing:2},
            ovBtnAlt:{background:"linear-gradient(135deg,#5d4037,#4e342e)"},
            gameRoot:{minHeight:"100vh",background:"linear-gradient(160deg,#1a0e05 0%,#2c1a0e 40%,#1a0e05 100%)",fontFamily:FONT,padding:"12px 16px",display:"flex",flexDirection:"column",alignItems:"center"},
            gHead:{display:"flex",alignItems:"center",justifyContent:"space-between",width:"100%",maxWidth:1060,marginBottom:12},
            backBtn:{background:"rgba(255,255,255,0.1)",color:"#d4a04a",border:"1px solid rgba(212,160,74,0.3)",borderRadius:8,padding:"6px 14px",cursor:"pointer",fontSize:14,fontFamily:FONT},
            gTitle:{color:"#e8c87a",fontSize:22,fontWeight:700,letterSpacing:4,margin:0},
            restBtn:{background:"rgba(255,255,255,0.1)",color:"#d4a04a",border:"1px solid rgba(212,160,74,0.3)",borderRadius:8,padding:"6px 14px",cursor:"pointer",fontSize:14,fontFamily:FONT},
            mainLay:{display:"flex",gap:16,alignItems:"flex-start",flexWrap:"wrap",justifyContent:"center"},
            sideP:{width:210,display:"flex",flexDirection:"column",gap:8},
            pPanel:{background:"rgba(245,230,200,0.95)",borderRadius:10,padding:"10px 12px",transition:"all 0.3s"},
            pRow:{display:"flex",alignItems:"center",gap:8},
            pDot:{width:12,height:12,borderRadius:"50%",flexShrink:0},
            pName:{fontSize:16,fontWeight:700,letterSpacing:2,flex:1},
            pTime:{fontSize:15,fontVariantNumeric:"tabular-nums",fontFamily:"'Courier New',monospace"},
            capRow:{display:"flex",flexWrap:"wrap",gap:3,marginTop:6},
            capP:{fontSize:15,fontWeight:600,opacity:0.7},
            mLog:{background:"rgba(245,230,200,0.92)",borderRadius:10,padding:"8px 10px",flex:1},
            mLogT:{fontSize:13,fontWeight:700,color:"#8B6914",letterSpacing:2},
            mLogL:{maxHeight:260,overflowY:"auto",fontSize:12,color:"#4a2c0a",lineHeight:1.8},
            mLogE:{color:"#aaa",fontSize:12,textAlign:"center",padding:12},
            mLogI:{padding:"2px 6px",borderRadius:4,display:"flex",alignItems:"center",gap:4},
            mNum:{color:"#8B6914",fontWeight:700,marginRight:2,fontSize:12,minWidth:22},
            undoSmall:{background:"transparent",border:"1px solid #c4a35a",borderRadius:5,padding:"2px 8px",cursor:"pointer",fontSize:11,color:"#8B6914",fontFamily:FONT},
            boardSvg:{display:"block",borderRadius:8,boxShadow:"0 8px 32px rgba(0,0,0,0.5)"},
            turnBar:{display:"flex",justifyContent:"center",marginTop:10},
            turnInd:{padding:"8px 24px",borderRadius:8,fontSize:16,fontWeight:700,letterSpacing:3,fontFamily:FONT,boxShadow:"0 3px 12px rgba(0,0,0,0.3)"},
            checkB:{marginLeft:10,padding:"2px 10px",background:"rgba(255,255,0,0.25)",borderRadius:6,fontSize:14,fontWeight:700},
            rulesC:{background:"rgba(245,230,200,0.95)",borderRadius:10,overflow:"hidden"},
            rulesT:{display:"flex",alignItems:"center",gap:8,width:"100%",padding:"12px 14px",background:"transparent",border:"none",cursor:"pointer",fontSize:15,color:"#4a2c0a",fontFamily:FONT,letterSpacing:2},
            rulesCt:{padding:"0 14px 14px",maxHeight:500,overflowY:"auto"},
            rSec:{marginBottom:14},
            rSecT:{fontSize:14,fontWeight:700,color:"#8B4513",margin:"0 0 6px",paddingBottom:4,borderBottom:"1px solid rgba(139,69,19,0.2)",letterSpacing:2},
            rTxt:{fontSize:12,color:"#4a2c0a",lineHeight:1.7,marginBottom:4},
            tCard:{background:"rgba(139,105,20,0.06)",border:"1px solid rgba(139,105,20,0.15)",borderRadius:6,padding:"8px 10px",marginBottom:6},
            tCardT:{fontSize:13,fontWeight:700,color:"#c62828",marginBottom:2},
            tCardD:{fontSize:11,color:"#5d4037",lineHeight:1.6},
            libGrid:{display:"grid",gridTemplateColumns:"repeat(auto-fill,minmax(220px,1fr))",gap:12,padding:"0 16px"},
            libCard:{background:"rgba(245,230,200,0.95)",borderRadius:10,padding:"14px 16px",border:"1.5px solid rgba(139,105,20,0.2)"},
            libCardName:{fontSize:18,fontWeight:800,color:"#4a2c0a",letterSpacing:2,marginBottom:4},
            libCardDesc:{fontSize:12,color:"#8B6914",lineHeight:1.5},
            libPlayBtn:{padding:"6px 14px",background:"linear-gradient(135deg,#c62828,#b71c1c)",color:"#fff",border:"none",borderRadius:6,cursor:"pointer",fontFamily:FONT,fontSize:13,fontWeight:700,letterSpacing:1},
            libFenBtn:{padding:"6px 10px",border:"1px solid #c4a35a",borderRadius:6,background:"transparent",cursor:"pointer",fontFamily:FONT,fontSize:12,color:"#8B6914"},
            libNote:{fontSize:12,color:"#c4a35a",textAlign:"center",lineHeight:1.7,marginTop:20,padding:"0 24px"},
        };

        // ─── Board Background SVG ───
        function BoardBG(){return(<><defs><filter id="ps" x="-30%" y="-30%" width="160%" height="160%"><feDropShadow dx="0" dy="2" stdDeviation="2" floodOpacity="0.35"/></filter><radialGradient id="rpg" cx="40%" cy="35%"><stop offset="0%" stopColor="#fff3e0"/><stop offset="100%" stopColor="#e8c87a"/></radialGradient><radialGradient id="bpg" cx="40%" cy="35%"><stop offset="0%" stopColor="#fff3e0"/><stop offset="100%" stopColor="#d4b96a"/></radialGradient><pattern id="wg" patternUnits="userSpaceOnUse" width="200" height="200"><rect width="200" height="200" fill="#d4a04a"/>{[20,55,85,120,155,185].map((y,i)=><line key={i} x1="0" y1={y} x2="200" y2={y+(i%2?-5:5)} stroke="#c8943f" strokeWidth={0.5+i*0.08} opacity={0.15+i*0.025}/>)}</pattern></defs><rect width={SVG_W} height={SVG_H} rx="6" fill="#b8862a"/><rect x="6" y="6" width={SVG_W-12} height={SVG_H-12} rx="3" fill="url(#wg)"/><rect x={PAD_X-4} y={PAD_TOP-4} width={BOARD_W+8} height={BOARD_H+8} fill="none" stroke="#8B6914" strokeWidth="3"/>{BLACK_COL_LABELS.map((l,i)=><text key={`bt${i}`} x={PAD_X+i*CELL} y={PAD_TOP-14} textAnchor="middle" fontFamily={FONT} fontSize="14" fontWeight="600" fill="#4a3b28" style={{userSelect:"none"}}>{l}</text>)}{RED_COL_LABELS.map((l,i)=><text key={`rb${i}`} x={PAD_X+i*CELL} y={PAD_TOP+BOARD_H+22} textAnchor="middle" fontFamily={FONT} fontSize="14" fontWeight="600" fill="#8B4513" style={{userSelect:"none"}}>{l}</text>)}{Array.from({length:10},(_,i)=><line key={`h${i}`} x1={PAD_X} y1={PAD_TOP+i*CELL} x2={PAD_X+BOARD_W} y2={PAD_TOP+i*CELL} stroke="#6B4C12" strokeWidth="1.2"/>)}{Array.from({length:9},(_,i)=><g key={`v${i}`}><line x1={PAD_X+i*CELL} y1={PAD_TOP} x2={PAD_X+i*CELL} y2={PAD_TOP+4*CELL} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+i*CELL} y1={PAD_TOP+5*CELL} x2={PAD_X+i*CELL} y2={PAD_TOP+9*CELL} stroke="#6B4C12" strokeWidth="1.2"/></g>)}<line x1={PAD_X} y1={PAD_TOP+4*CELL} x2={PAD_X} y2={PAD_TOP+5*CELL} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+8*CELL} y1={PAD_TOP+4*CELL} x2={PAD_X+8*CELL} y2={PAD_TOP+5*CELL} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+3*CELL} y1={PAD_TOP} x2={PAD_X+5*CELL} y2={PAD_TOP+2*CELL} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+5*CELL} y1={PAD_TOP} x2={PAD_X+3*CELL} y2={PAD_TOP+2*CELL} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+3*CELL} y1={PAD_TOP+7*CELL} x2={PAD_X+5*CELL} y2={PAD_TOP+9*CELL} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+5*CELL} y1={PAD_TOP+7*CELL} x2={PAD_X+3*CELL} y2={PAD_TOP+9*CELL} stroke="#6B4C12" strokeWidth="1.2"/><text x={PAD_X+2*CELL} y={PAD_TOP+4.5*CELL} textAnchor="middle" fontFamily={FONT} fontSize="24" fontWeight="700" fill="#4a3b28" opacity="0.25" style={{userSelect:"none"}}>楚 河</text><text x={PAD_X+6*CELL} y={PAD_TOP+4.5*CELL} textAnchor="middle" fontFamily={FONT} fontSize="24" fontWeight="700" fill="#4a3b28" opacity="0.25" style={{userSelect:"none"}}>汉 界</text>{[[1,2],[7,2],[1,7],[7,7]].map(([c,r],i)=><g key={`m${i}`}><line x1={PAD_X+c*CELL-5} y1={PAD_TOP+r*CELL-12} x2={PAD_X+c*CELL-5} y2={PAD_TOP+r*CELL-4} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+c*CELL-5} y1={PAD_TOP+r*CELL+4} x2={PAD_X+c*CELL-5} y2={PAD_TOP+r*CELL+12} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+c*CELL+5} y1={PAD_TOP+r*CELL-12} x2={PAD_X+c*CELL+5} y2={PAD_TOP+r*CELL-4} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+c*CELL+5} y1={PAD_TOP+r*CELL+4} x2={PAD_X+c*CELL+5} y2={PAD_TOP+r*CELL+12} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+c*CELL-12} y1={PAD_TOP+r*CELL-5} x2={PAD_X+c*CELL-4} y2={PAD_TOP+r*CELL-5} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+c*CELL+4} y1={PAD_TOP+r*CELL-5} x2={PAD_X+c*CELL+12} y2={PAD_TOP+r*CELL-5} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+c*CELL-12} y1={PAD_TOP+r*CELL+5} x2={PAD_X+c*CELL-4} y2={PAD_TOP+r*CELL+5} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+c*CELL+4} y1={PAD_TOP+r*CELL+5} x2={PAD_X+c*CELL+12} y2={PAD_TOP+r*CELL+5} stroke="#6B4C12" strokeWidth="1.2"/></g>)}{[[0,3],[2,3],[4,3],[6,3],[8,3],[0,6],[2,6],[4,6],[6,6],[8,6]].map(([c,r],i)=><g key={`s${i}`}><line x1={PAD_X+c*CELL+12} y1={PAD_TOP+r*CELL-5} x2={PAD_X+c*CELL+4} y2={PAD_TOP+r*CELL-5} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+c*CELL+12} y1={PAD_TOP+r*CELL+5} x2={PAD_X+c*CELL+4} y2={PAD_TOP+r*CELL+5} stroke="#6B4C12" strokeWidth="1.2"/></g>)}{[[0,3],[2,3],[4,3],[6,3],[8,3],[0,6],[2,6],[4,6],[6,6],[8,6]].map(([c,r],i)=><g key={`s2${i}`}><line x1={PAD_X+c*CELL-12} y1={PAD_TOP+r*CELL-5} x2={PAD_X+c*CELL-4} y2={PAD_TOP+r*CELL-5} stroke="#6B4C12" strokeWidth="1.2"/><line x1={PAD_X+c*CELL-12} y1={PAD_TOP+r*CELL+5} x2={PAD_X+c*CELL-4} y2={PAD_TOP+r*CELL+5} stroke="#6B4C12" strokeWidth="1.2"/></g>)}</>);}

        function PieceSVG({type,side,cx,cy,onClick,isSelected,dim,onMouseDown:omd,onTouchStart:ots}){const R=CELL/2-4;return(<g onClick={onClick} style={{cursor:"pointer",opacity:dim?0.3:1}} filter="url(#ps)" onMouseDown={omd} onTouchStart={ots}>{isSelected&&<circle cx={cx} cy={cy} r={R+4} fill="none" stroke="#FFD700" strokeWidth="3" opacity="0.8"><animate attributeName="r" values={`${R+3};${R+6};${R+3}`} dur="1.2s" repeatCount="indefinite"/></circle>}<circle cx={cx} cy={cy} r={R} fill={side===RED?"url(#rpg)":"url(#bpg)"} stroke={side===RED?"#8B4513":"#3e3122"} strokeWidth="2"/><circle cx={cx} cy={cy} r={R-4} fill="none" stroke={side===RED?"#a0522d":"#4a3b28"} strokeWidth="0.8"/><text x={cx} y={cy+1} textAnchor="middle" dominantBaseline="central" fontFamily={FONT} fontWeight="800" fontSize="21" fill={side===RED?"#b71c1c":"#1a1a1a"} style={{userSelect:"none",pointerEvents:"none"}}>{PIECE_NAMES[type][side]}</text></g>);}

        function EditorRulesPanel({show,toggle}){
            return(<div style={ST.rulesC}><button style={ST.rulesT} onClick={toggle}><span>{show?"\u25bc":"\u25b6"}</span><span style={{fontWeight:700}}>布局规则说明</span></button>
            {show&&<div style={ST.rulesCt}>
                <section style={ST.rSec}><h4 style={ST.rSecT}>摆放约束</h4>
                    <div style={ST.rTxt}><b>帥/將</b>：只能放在己方九宫格内（9个交叉点）。</div>
                    <div style={ST.rTxt}><b>仕/士</b>：只能放在九宫格的<b>对角线交叉点</b>上（中心1点 + 四角4点，每方共5个合法位置）。</div>
                    <div style={ST.rTxt}><b>相/象</b>：只能放在己方半场的<b>"田"字对角位</b>上，不可过河（每方共7个合法位置）。</div>
                    <div style={ST.rTxt}><b>馬/车/炮/兵</b>：棋盘任意空位均可放置。</div>
                </section>
                <section style={ST.rSec}><h4 style={ST.rSecT}>数量限制</h4>
                    <div style={ST.rTxt}>帥/將 ×1，仕/士 ×2，相/象 ×2，馬/马 ×2，車/车 ×2，炮/砲 ×2，兵/卒 ×5。</div>
                </section>
                <section style={ST.rSec}><h4 style={ST.rSecT}>先手方</h4>
                    <div style={ST.rTxt}>残局未必红方先手。请根据棋局设定选择「红先」或「黑先」，导出时先手方信息会包含在数据中。</div>
                </section>
            </div>}</div>);
        }

        // ═══════════════════════════════════════
        // ─── Board Editor (with name & export) ───
        // ═══════════════════════════════════════
        function BoardEditor({onStart,onBack}){
            const [board,setBoard]=useState(emptyBoard);
            const [firstTurn,setFirstTurn]=useState(RED);
            const [gameName,setGameName]=useState("");
            const [dragPiece,setDragPiece]=useState(null);
            const [dragFrom,setDragFrom]=useState(null);
            const [dragPos,setDragPos]=useState(null);
            const [hoverCell,setHoverCell]=useState(null);
            const [error,setError]=useState("");
            const [showExport,setShowExport]=useState(false);
            const [exportStr,setExportStr]=useState("");
            const [copyOk,setCopyOk]=useState(false);
            const [showEditorRules,setShowEditorRules]=useState(false);
            const svgRef=useRef(null);
            const getAvail=(type,side)=>PIECE_MAX[type]-countOnBoard(board,type,side);
            const screenToCell=useCallback((cx,cy)=>{if(!svgRef.current)return null;const rect=svgRef.current.getBoundingClientRect();const sx=SVG_W/rect.width,sy=SVG_H/rect.height;const bx=(cx-rect.left)*sx-PAD_X,by=(cy-rect.top)*sy-PAD_TOP;const col=Math.round(bx/CELL),row=Math.round(by/CELL);if(row>=0&&row<ROWS&&col>=0&&col<COLS)return[row,col];return null;},[]);
            const handleMove=useCallback((e)=>{const cx=e.touches?e.touches[0].clientX:e.clientX;const cy=e.touches?e.touches[0].clientY:e.clientY;setDragPos({x:cx,y:cy});setHoverCell(screenToCell(cx,cy));},[screenToCell]);
            const handleUp=useCallback((e)=>{if(!dragPiece)return;const cx=e.changedTouches?e.changedTouches[0].clientX:e.clientX;const cy=e.changedTouches?e.changedTouches[0].clientY:e.clientY;const cell=screenToCell(cx,cy);if(cell){const[row,col]=cell;if(isValidPlacement(dragPiece.type,dragPiece.side,row,col)){const nb=cloneBoard(board);if(dragFrom)nb[dragFrom[0]][dragFrom[1]]=null;nb[row][col]={type:dragPiece.type,side:dragPiece.side};setBoard(nb);setError("");}}else if(dragFrom){const nb=cloneBoard(board);nb[dragFrom[0]][dragFrom[1]]=null;setBoard(nb);}setDragPiece(null);setDragFrom(null);setDragPos(null);setHoverCell(null);},[dragPiece,dragFrom,board,screenToCell]);
            useEffect(()=>{if(dragPiece){window.addEventListener("mousemove",handleMove);window.addEventListener("mouseup",handleUp);window.addEventListener("touchmove",handleMove,{passive:false});window.addEventListener("touchend",handleUp);return()=>{window.removeEventListener("mousemove",handleMove);window.removeEventListener("mouseup",handleUp);window.removeEventListener("touchmove",handleMove);window.removeEventListener("touchend",handleUp);};};},[dragPiece,handleMove,handleUp]);
            const startDrag=(type,side,fromBoard,e)=>{e.preventDefault();const cx=e.touches?e.touches[0].clientX:e.clientX;const cy=e.touches?e.touches[0].clientY:e.clientY;setDragPiece({type,side});setDragFrom(fromBoard);setDragPos({x:cx,y:cy});};
            const validate=()=>{if(!findKing(board,RED))return"请放置红方帥";if(!findKing(board,BLACK))return"请放置黑方將";let t=0;for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(board[r][c])t++;if(t<3)return"至少需要3个棋子";return null;};
            const handleStart=()=>{const err=validate();if(err){setError(err);return;}onStart(gameName||"自定义残局",cloneBoard(board),firstTurn);};
            const handleExport=()=>{const err=validate();if(err){setError(err);return;}setExportStr(exportEndgame(gameName||"未命名残局",board,firstTurn));setShowExport(true);setCopyOk(false);};
            const handleCopy=()=>{navigator.clipboard?.writeText(exportStr).then(()=>setCopyOk(true)).catch(()=>{});};
            const handleImportToEditor=(str)=>{const result=importEndgame(str);if(!result){setError("无法解析导入数据");return;}setBoard(result.board);setFirstTurn(result.turn);setGameName(result.name);setError("");};
            const hoverValid=hoverCell&&dragPiece?isValidPlacement(dragPiece.type,dragPiece.side,hoverCell[0],hoverCell[1]):false;

            const PaletteCol=({side:s})=>(<div style={ST.palette}><div style={ST.palTitle}><span style={{...ST.palDot,background:s===RED?"#c62828":"#222"}}/>{s===RED?"红方棋子":"黑方棋子"}</div><div style={ST.palHelp}>拖拽至棋盘放置</div>{ALL_PIECE_TYPES.map(t=>{const av=getAvail(t,s);return(<div key={t} style={{...ST.palItem,opacity:av>0?1:0.3,cursor:av>0?"grab":"default"}} onMouseDown={av>0?(e)=>startDrag(t,s,null,e):undefined} onTouchStart={av>0?(e)=>startDrag(t,s,null,e):undefined}><span style={{fontFamily:FONT,fontWeight:800,fontSize:22,color:s===RED?"#b71c1c":"#1a1a1a",width:30,textAlign:"center"}}>{PIECE_NAMES[t][s]}</span><span style={ST.palCount}>×{av}</span></div>);})}</div>);

            return(
                <div style={ST.edRoot}>
                    <div style={ST.edHead}><button style={ST.backBtn} onClick={onBack}>← 返回</button><h2 style={ST.edTitle}>残局布局设计器</h2><div style={{width:72}}/></div>
                    <div style={ST.edBody}>
                        <PaletteCol side={RED}/>
                        <div style={{position:"relative"}}>
                            <svg ref={svgRef} width={SVG_W} height={SVG_H} style={ST.boardSvg}><BoardBG/>{hoverCell&&dragPiece&&<circle cx={PAD_X+hoverCell[1]*CELL} cy={PAD_TOP+hoverCell[0]*CELL} r={CELL/2-2} fill={hoverValid?"rgba(76,175,80,0.2)":"rgba(244,67,54,0.2)"} stroke={hoverValid?"#4caf50":"#f44336"} strokeWidth="2" strokeDasharray="5 3"/>}{board.map((row,r)=>row.map((piece,c)=>{if(!piece)return null;const isDrag=dragFrom&&dragFrom[0]===r&&dragFrom[1]===c;return <PieceSVG key={`${r}-${c}`} type={piece.type} side={piece.side} cx={PAD_X+c*CELL} cy={PAD_TOP+r*CELL} dim={isDrag} onClick={()=>{}}/>;}))}{board.map((row,r)=>row.map((piece,c)=>{if(!piece)return null;return <rect key={`z${r}-${c}`} x={PAD_X+c*CELL-CELL/2} y={PAD_TOP+r*CELL-CELL/2} width={CELL} height={CELL} fill="transparent" onContextMenu={(e)=>{e.preventDefault();const nb=cloneBoard(board);nb[r][c]=null;setBoard(nb);}} onMouseDown={(e)=>{if(e.button===0)startDrag(piece.type,piece.side,[r,c],e);}} onTouchStart={(e)=>startDrag(piece.type,piece.side,[r,c],e)} style={{cursor:"grab"}}/>;}))}</svg>
                            {dragPiece&&dragPos&&<div style={{position:"fixed",left:dragPos.x-24,top:dragPos.y-24,width:48,height:48,borderRadius:"50%",background:dragPiece.side===RED?"linear-gradient(135deg,#fff3e0,#e8c87a)":"linear-gradient(135deg,#fff3e0,#d4b96a)",border:`2px solid ${dragPiece.side===RED?"#8B4513":"#3e3122"}`,display:"flex",alignItems:"center",justifyContent:"center",fontFamily:FONT,fontWeight:800,fontSize:20,color:dragPiece.side===RED?"#b71c1c":"#1a1a1a",pointerEvents:"none",zIndex:9999,boxShadow:"0 6px 20px rgba(0,0,0,0.4)",transform:"scale(1.1)"}}>{PIECE_NAMES[dragPiece.type][dragPiece.side]}</div>}
                        </div>
                        <div style={{display:"flex",flexDirection:"column",gap:10,width:180}}>
                            <PaletteCol side={BLACK}/>
                            <div style={ST.palette}>
                                <div style={{marginBottom:6}}><div style={ST.ctrlLabel}>残局名称</div><input style={ST.nameInput} placeholder="例：七星聚会" value={gameName} onChange={e=>setGameName(e.target.value)}/></div>
                                <div style={{marginBottom:6}}><div style={ST.ctrlLabel}>先手方</div><div style={{display:"flex",gap:6}}><button style={{...ST.turnBtn,...(firstTurn===RED?ST.turnBtnR:{})}} onClick={()=>setFirstTurn(RED)}>红先</button><button style={{...ST.turnBtn,...(firstTurn===BLACK?ST.turnBtnB:{})}} onClick={()=>setFirstTurn(BLACK)}>黑先</button></div></div>
                                <div style={{display:"flex",gap:6}}><button style={{...ST.clearBtn,flex:1}} onClick={()=>{setBoard(emptyBoard());setError("");}}>清空</button><button style={{...ST.clearBtn,flex:1}} onClick={handleExport}>导出</button></div>
                                <ImportBox onImport={handleImportToEditor} label="导入到编辑器"/>
                                {error&&<div style={ST.errMsg}>{error}</div>}
                                <button style={ST.startBtn} onClick={handleStart}>开始对弈</button>
                                <div style={ST.edTip}>拖拽棋子至棋盘。棋盘上可拖拽调整，拖出棋盘外或右键移除。</div>
                            </div>
                            <EditorRulesPanel show={showEditorRules} toggle={()=>setShowEditorRules(!showEditorRules)}/>
                        </div>
                    </div>
                    {showExport&&<div style={ST.overlay} onClick={()=>setShowExport(false)}><div style={ST.modalBox} onClick={e=>e.stopPropagation()}><div style={ST.modalTitle}>导出残局</div><div style={{textAlign:"center",marginBottom:8}}><span style={{fontSize:13,fontWeight:700,padding:"3px 12px",borderRadius:5,background:firstTurn===RED?"rgba(198,40,40,0.12)":"rgba(33,33,33,0.1)",color:firstTurn===RED?"#c62828":"#333",letterSpacing:1}}>{gameName||"未命名残局"} - {firstTurn===RED?"红先":"黑先"}</span></div><div style={ST.modalHint}>复制以下文本，可用于导入到经典残局谱或分享给他人：</div><textarea style={ST.modalTextarea} readOnly value={exportStr} onFocus={e=>e.target.select()}/><div style={{display:"flex",gap:8,justifyContent:"center",marginTop:10}}><button style={ST.modalBtn} onClick={handleCopy}>{copyOk?"✓ 已复制":"复制到剪贴板"}</button><button style={{...ST.modalBtn,...ST.modalBtnAlt}} onClick={()=>setShowExport(false)}>关闭</button></div></div></div>}
                </div>
            );
        }

        // ─── Import Box (reusable) ───
        function ImportBox({onImport,label}){
            const [show,setShow]=useState(false);
            const [text,setText]=useState("");
            const [err,setErr]=useState("");
            const doImport=()=>{if(!text.trim()){setErr("请粘贴残局数据");return;}const r=importEndgame(text.trim());if(!r){setErr("格式无法识别");return;}setErr("");setText("");setShow(false);onImport(text.trim());};
            if(!show) return <button style={ST.importToggle} onClick={()=>setShow(true)}>+ {label||"导入残局"}</button>;
            return(<div style={ST.importBox}><textarea style={ST.importTextarea} placeholder="粘贴导出的残局数据 (JSON 或 FEN)…" value={text} onChange={e=>{setText(e.target.value);setErr("");}}/>{err&&<div style={{fontSize:11,color:"#c62828"}}>{err}</div>}<div style={{display:"flex",gap:4}}><button style={ST.importBtn} onClick={doImport}>确认导入</button><button style={{...ST.importBtn,background:"transparent",color:"#8B6914"}} onClick={()=>{setShow(false);setText("");setErr("");}}>取消</button></div></div>);
        }

        // ═══════════════════════════════════════
        // ─── Endgame Library ───
        // ═══════════════════════════════════════
        function EndgameLibrary({onStart,onBack}){
            const [imported,setImported]=useState([]);
            const handleImport=(str)=>{const r=importEndgame(str);if(r) setImported(prev=>[...prev,{name:r.name,desc:"导入的残局",fen:boardToFen(r.board,r.turn)}]);};
            const allEndgames=[...CLASSIC_ENDGAMES,...imported.map(i=>({...i}))];
            const startEndgame=(eg)=>{const r=fenToBoard(eg.fen);if(!r)return;onStart(eg.name,r.board,r.turn);};
            return(
                <div style={ST.edRoot}>
                    <div style={ST.edHead}><button style={ST.backBtn} onClick={onBack}>← 返回</button><h2 style={ST.edTitle}>经典残局谱</h2><div style={{width:72}}/></div>
                    <div style={{maxWidth:800,width:"100%"}}>
                        <div style={{marginBottom:12,display:"flex",justifyContent:"center"}}><ImportBox onImport={handleImport} label="导入残局到列表"/></div>
                        <div style={ST.libGrid}>
                            {allEndgames.map((eg,i)=>{
                                const parsed=fenToBoard(eg.fen);
                                const valid=parsed&&findKing(parsed.board,RED)&&findKing(parsed.board,BLACK);
                                const firstSide=parsed?parsed.turn:RED;
                                return(
                                    <div key={i} style={ST.libCard}>
                                        <div style={{display:"flex",alignItems:"center",justifyContent:"space-between"}}><div style={ST.libCardName}>{eg.name}</div><span style={{fontSize:12,fontWeight:700,padding:"2px 8px",borderRadius:4,background:firstSide===RED?"rgba(198,40,40,0.12)":"rgba(33,33,33,0.1)",color:firstSide===RED?"#c62828":"#333",letterSpacing:1,flexShrink:0}}>{firstSide===RED?"红先":"黑先"}</span></div>
                                        <div style={ST.libCardDesc}>{eg.desc}</div>
                                        <div style={{display:"flex",gap:6,marginTop:8}}>
                                            {valid&&<button style={ST.libPlayBtn} onClick={()=>startEndgame(eg)}>开始对弈</button>}
                                            <button style={ST.libFenBtn} onClick={()=>{navigator.clipboard?.writeText(exportEndgame(eg.name,parsed?.board||emptyBoard(),parsed?.turn||RED));}}>复制</button>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                        <div style={ST.libNote}>提示：在「手工布局」中摆好棋局后点击「导出」，再到此处点击「导入残局到列表」即可添加。开发者也可直接将 FEN 写入代码中的 CLASSIC_ENDGAMES 数组实现永久收录。</div>
                    </div>
                </div>
            );
        }

        // ═══════════════════════════════════════
        // ─── Main Component ───
        // ═══════════════════════════════════════
        function XiangqiGame(){
            const [screen,setScreen]=useState("menu");
            const [gameMode,setGameMode]=useState("standard");
            const [gameLabel,setGameLabel]=useState("");
            const [board,setBoard]=useState(createStandardBoard);
            const [turn,setTurn]=useState(RED);
            const [initialTurn,setInitialTurn]=useState(RED);
            const [selected,setSelected]=useState(null);
            const [validMoves,setValidMoves]=useState([]);
            const [gameOver,setGameOver]=useState(null);
            const [redTime,setRedTime]=useState(0);
            const [blackTime,setBlackTime]=useState(0);
            const [moveHistory,setMoveHistory]=useState([]);
            const [lastMove,setLastMove]=useState(null);
            const [showRules,setShowRules]=useState(false);
            const [capturedRed,setCapturedRed]=useState([]);
            const [capturedBlack,setCapturedBlack]=useState([]);
            const [initBoard,setInitBoard]=useState(null);
            const [undoStack,setUndoStack]=useState([]);
            const timerRef=useRef(null);

            useEffect(()=>{if(screen==="game"&&!gameOver){timerRef.current=setInterval(()=>{if(turn===RED)setRedTime(t=>t+1);else setBlackTime(t=>t+1);},1000);}return()=>clearInterval(timerRef.current);},[turn,screen,gameOver]);
            const resetGS=()=>{setSelected(null);setValidMoves([]);setGameOver(null);setRedTime(0);setBlackTime(0);setMoveHistory([]);setLastMove(null);setCapturedRed([]);setCapturedBlack([]);setUndoStack([]);};
            const startStandard=()=>{const b=createStandardBoard();setBoard(b);setInitBoard(cloneBoard(b));setTurn(RED);setInitialTurn(RED);setGameMode("standard");setGameLabel("标准对弈");resetGS();setScreen("game");};
            const startFromEditor=(name,b,ft)=>{setBoard(b);setInitBoard(cloneBoard(b));setTurn(ft);setInitialTurn(ft);setGameMode("endgame");setGameLabel(name);resetGS();setScreen("game");};
            const startFromLibrary=(name,b,ft)=>{setBoard(b);setInitBoard(cloneBoard(b));setTurn(ft);setInitialTurn(ft);setGameMode("endgame");setGameLabel(name);resetGS();setScreen("game");};
            const restartGame=()=>{if(initBoard)setBoard(cloneBoard(initBoard));setTurn(initialTurn);resetGS();};
            const handleUndo=()=>{if(undoStack.length===0)return;const prev=undoStack[undoStack.length-1];setUndoStack(s=>s.slice(0,-1));setBoard(prev.board);setTurn(prev.turn);setCapturedRed(prev.cr);setCapturedBlack(prev.cb);setLastMove(prev.lm);setMoveHistory(h=>h.slice(0,-1));setSelected(null);setValidMoves([]);setGameOver(null);};

            const handleCellClick=(r,c)=>{if(gameOver)return;const piece=board[r][c];if(selected){const[sr,sc]=selected;if(validMoves.some(([mr,mc])=>mr===r&&mc===c)){setUndoStack(s=>[...s,{board:cloneBoard(board),turn,cr:[...capturedRed],cb:[...capturedBlack],lm:lastMove}]);const nb=board.map(row=>row.slice());const cap=nb[r][c];const notation=formatMove(nb,sr,sc,r,c);nb[r][c]=nb[sr][sc];nb[sr][sc]=null;setBoard(nb);setLastMove({from:[sr,sc],to:[r,c]});setMoveHistory(h=>[...h,notation]);if(cap){if(cap.side===RED)setCapturedRed(p=>[...p,cap]);else setCapturedBlack(p=>[...p,cap]);}setSelected(null);setValidMoves([]);const nt=turn===RED?BLACK:RED;if(!findKing(nb,nt)){setGameOver(turn===RED?"红方胜！":"黑方胜！");return;}if(isInCheck(nb,nt)&&!hasAnyMoves(nb,nt)){setGameOver(turn===RED?"将杀！红方胜！":"将杀！黑方胜！");return;}if(!hasAnyMoves(nb,nt)){setGameOver("困毙！"+(turn===RED?"红方胜！":"黑方胜！"));return;}setTurn(nt);return;}if(piece?.side===turn){setSelected([r,c]);setValidMoves(getValidMoves(board,r,c));return;}setSelected(null);setValidMoves([]);return;}if(piece?.side===turn){setSelected([r,c]);setValidMoves(getValidMoves(board,r,c));}};
            const isCheck=screen==="game"&&!gameOver&&isInCheck(board,turn);

            if(screen==="menu")return(
                <div style={ST.menuRoot}><div style={ST.menuBox}>
                    <div style={ST.menuDecor}/><h1 style={ST.menuTitle}>中國象棋</h1><p style={ST.menuSub}>楚 河 漢 界</p><div style={ST.menuLine}/>
                    <button style={ST.menuPri} onClick={startStandard}><span style={ST.menuIco}>⚔</span><div><div style={ST.menuLbl}>标准对弈</div><div style={ST.menuDsc}>双人对弈，完整棋盘开局</div></div></button>
                    <div style={{height:14}}/>
                    <button style={ST.menuSec} onClick={()=>setScreen("editor")}><span style={ST.menuIco}>✎</span><div><div style={ST.menuLbl}>残局对弈 · 手工布局</div><div style={ST.menuDsc}>自由摆放棋子，设计残局局面并导出</div></div></button>
                    <div style={{height:10}}/>
                    <button style={ST.menuSec2} onClick={()=>setScreen("library")}><span style={ST.menuIco}>📖</span><div><div style={ST.menuLbl}>残局对弈 · 经典残局谱</div><div style={ST.menuDsc}>{CLASSIC_ENDGAMES.length} 局预制 + 支持导入自定义残局</div></div></button>
                    <div style={{...ST.menuDecor,marginTop:28,marginBottom:0}}/>
                </div></div>
            );

            if(screen==="editor")return <BoardEditor onStart={startFromEditor} onBack={()=>setScreen("menu")}/>;
            if(screen==="library")return <EndgameLibrary onStart={startFromLibrary} onBack={()=>setScreen("menu")}/>;

            return(
                <div style={ST.gameRoot}>
                    <div style={ST.gHead}><button style={ST.backBtn} onClick={()=>setScreen("menu")}>← 返回</button><h2 style={ST.gTitle}>{gameLabel}</h2><div style={{display:"flex",gap:8}}><button style={{...ST.restBtn,opacity:undoStack.length===0?0.4:1}} onClick={handleUndo} disabled={undoStack.length===0}>↩ 悔棋</button><button style={ST.restBtn} onClick={restartGame}>↻ 重来</button></div></div>
                    <div style={ST.mainLay}>
                        <div style={ST.sideP}>
                            <PlayerPanel side={BLACK} time={blackTime} isTurn={turn===BLACK&&!gameOver} captured={capturedBlack}/>
                            <MoveLog moves={moveHistory} onUndo={handleUndo} canUndo={undoStack.length>0&&!gameOver}/>
                            <PlayerPanel side={RED} time={redTime} isTurn={turn===RED&&!gameOver} captured={capturedRed}/>
                        </div>
                        <div style={{position:"relative"}}>
                            <svg width={SVG_W} height={SVG_H} style={ST.boardSvg}><BoardBG/>{lastMove&&<><rect x={PAD_X+lastMove.from[1]*CELL-CELL/2+2} y={PAD_TOP+lastMove.from[0]*CELL-CELL/2+2} width={CELL-4} height={CELL-4} fill="rgba(255,215,0,0.15)" rx="4"/><rect x={PAD_X+lastMove.to[1]*CELL-CELL/2+2} y={PAD_TOP+lastMove.to[0]*CELL-CELL/2+2} width={CELL-4} height={CELL-4} fill="rgba(255,215,0,0.25)" rx="4"/></>}{validMoves.map(([mr,mc])=>{const tx=PAD_X+mc*CELL,ty=PAD_TOP+mr*CELL;return board[mr][mc]?<circle key={`v${mr}-${mc}`} cx={tx} cy={ty} r={CELL/2-4} fill="none" stroke="rgba(200,50,50,0.5)" strokeWidth="3" strokeDasharray="6 3"/>:<circle key={`v${mr}-${mc}`} cx={tx} cy={ty} r={7} fill="rgba(50,120,50,0.5)"/>;})}{board.map((row,r)=>row.map((piece,c)=>{if(!piece)return null;return <PieceSVG key={`p${r}-${c}`} type={piece.type} side={piece.side} cx={PAD_X+c*CELL} cy={PAD_TOP+r*CELL} isSelected={selected&&selected[0]===r&&selected[1]===c} onClick={()=>handleCellClick(r,c)}/>;}))}{board.map((row,r)=>row.map((piece,c)=>{if(piece)return null;return <rect key={`e${r}-${c}`} x={PAD_X+c*CELL-CELL/2} y={PAD_TOP+r*CELL-CELL/2} width={CELL} height={CELL} fill="transparent" onClick={()=>handleCellClick(r,c)} style={{cursor:validMoves.some(([mr,mc])=>mr===r&&mc===c)?"pointer":"default"}}/>;}))}</svg>
                            {gameOver&&<div style={ST.overlay}><div style={ST.ovBox}><div style={ST.ovTitle}>{gameOver}</div><div style={ST.ovBtns}><button style={ST.ovBtn} onClick={restartGame}>再来一局</button><button style={{...ST.ovBtn,...ST.ovBtnAlt}} onClick={()=>setScreen("menu")}>返回菜单</button></div></div></div>}
                            {!gameOver&&<div style={ST.turnBar}><div style={{...ST.turnInd,background:turn===RED?"linear-gradient(135deg,#c62828,#e53935)":"linear-gradient(135deg,#212121,#424242)",color:"#fff"}}>{turn===RED?"红方":"黑方"}走棋{isCheck&&<span style={ST.checkB}>将军!</span>}</div></div>}
                        </div>
                        <div style={{width:240}}><RulesPanel show={showRules} toggle={()=>setShowRules(!showRules)}/></div>
                    </div>
                </div>
            );
        }

        // ─── Sub Components ───
        function PlayerPanel({side,time,isTurn,captured}){return(<div style={{...ST.pPanel,borderLeft:isTurn?`4px solid ${side===RED?"#c62828":"#333"}`:"4px solid transparent",background:isTurn?(side===RED?"rgba(198,40,40,0.06)":"rgba(33,33,33,0.06)"):"transparent"}}><div style={ST.pRow}><div style={{...ST.pDot,background:side===RED?"#c62828":"#222"}}/><span style={{...ST.pName,color:side===RED?"#c62828":"#222"}}>{side===RED?"红 方":"黑 方"}</span><span style={{...ST.pTime,color:isTurn?(side===RED?"#c62828":"#222"):"#999",fontWeight:isTurn?700:400}}>⏱ {fmtTime(time)}</span></div>{captured.length>0&&<div style={ST.capRow}>{captured.map((p,i)=><span key={i} style={{...ST.capP,color:p.side===RED?"#c62828":"#222"}}>{PIECE_NAMES[p.type][p.side]}</span>)}</div>}</div>);}

        function MoveLog({moves,onUndo,canUndo}){const ref=useRef(null);useEffect(()=>{if(ref.current)ref.current.scrollTop=ref.current.scrollHeight;},[moves]);return(<div style={ST.mLog}><div style={{display:"flex",alignItems:"center",justifyContent:"space-between",marginBottom:4}}><div style={ST.mLogT}>走棋记录</div>{canUndo&&<button onClick={onUndo} style={ST.undoSmall}>↩ 悔棋</button>}</div><div ref={ref} style={ST.mLogL}>{moves.length===0&&<div style={ST.mLogE}>暂无走棋</div>}{moves.map((m,i)=>{const isRed=m.side===RED;const rn=Math.floor(i/2)+1;return(<div key={i} style={{...ST.mLogI,background:i%2===0?"rgba(0,0,0,0.02)":"transparent"}}>{i%2===0&&<span style={ST.mNum}>{rn}.</span>}{i%2!==0&&<span style={{...ST.mNum,opacity:0}}>{rn}.</span>}<span style={{color:isRed?"#b71c1c":"#333",fontWeight:600,padding:"1px 6px",borderRadius:3,background:isRed?"rgba(183,28,28,0.08)":"rgba(0,0,0,0.05)",fontSize:13,letterSpacing:1}}>{m.text}</span></div>);})}</div></div>);}

        function RulesPanel({show,toggle}){return(<div style={ST.rulesC}><button style={ST.rulesT} onClick={toggle}><span>{show?"▼":"▶"}</span><span style={{fontWeight:700}}>棋规与战法</span></button>{show&&<div style={ST.rulesCt}><section style={ST.rSec}><h4 style={ST.rSecT}>基本规则</h4><div style={ST.rTxt}><b>帥/將</b>：九宫格内上下左右一格，不可面对面。</div><div style={ST.rTxt}><b>仕/士</b>：九宫格内斜走一格。</div><div style={ST.rTxt}><b>相/象</b>：走"田"字对角，不过河，塞象眼。</div><div style={ST.rTxt}><b>馬/马</b>：走"日"字，蹩马腿。</div><div style={ST.rTxt}><b>車/车</b>：横竖直线任意距离，不越子。</div><div style={ST.rTxt}><b>炮/砲</b>：移动同車，吃子须隔一子。</div><div style={ST.rTxt}><b>兵/卒</b>：未过河仅前进；过河后可左右前进。</div></section><section style={ST.rSec}><h4 style={ST.rSecT}>棋谱记法</h4><div style={ST.rTxt}>格式：<b>棋子+列号+动作+目标</b></div><div style={ST.rTxt}>红方列号从右到左<b>一至九</b>，黑方从左到右<b>1至9</b>。</div><div style={ST.rTxt}><b>进</b>＝向前，<b>退</b>＝向后，<b>平</b>＝横移。</div><div style={ST.rTxt}>同列两同子用<b>前/后</b>（仕相除外）。</div><div style={ST.rTxt}><b>多兵同列</b>：3个前/中/后；4个前/二/三/四。</div><div style={ST.rTxt}><b>多列多兵</b>：按右到左、前到后编号一~五。</div></section><section style={ST.rSec}><h4 style={ST.rSecT}>胜负</h4><div style={ST.rTxt}>将死或困毙对方即获胜。</div></section><section style={ST.rSec}><h4 style={ST.rSecT}>常见战法</h4>{[["当头炮","开局炮移中路瞄准将门。"],["屏风马","双马并列护中卒。"],["马后炮","马控逃路、炮在马后绝杀。"],["铁门栓","車沉底封锁将门。"],["双車錯","两車轮流将军至杀。"],["弃子攻杀","牺牲一子创造绝杀。"]].map(([t,d])=><div key={t} style={ST.tCard}><div style={ST.tCardT}>{t}</div><div style={ST.tCardD}>{d}</div></div>)}</section></div>}</div>);}

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(XiangqiGame));
    </script>
</body>
</html>
