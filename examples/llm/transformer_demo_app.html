<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformeræ¶æ„å®Œæ•´æ¼”ç¤º</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #667eea;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        h2 {
            color: #764ba2;
            margin-top: 30px;
            margin-bottom: 20px;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        .output {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .matrix-viz {
            display: inline-block;
            margin: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .attention-grid {
            display: grid;
            gap: 2px;
            margin: 10px 0;
            background: #ddd;
            padding: 2px;
            border-radius: 4px;
            display: inline-block;
        }
        .attention-cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: bold;
        }
        .training-log {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .generation-step {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .token {
            display: inline-block;
            padding: 4px 8px;
            margin: 2px;
            background: #f0f0f0;
            border-radius: 4px;
            font-family: monospace;
        }
        .highlight {
            background: #ffeb3b;
            font-weight: bold;
        }
        canvas {
            border: 1px solid #ddd;
            border-radius: 8px;
            margin: 10px 0;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: transform 0.2s;
        }
        button:hover {
            transform: scale(1.05);
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤– Transformeræ¶æ„å®Œæ•´æ¼”ç¤º - è®­ç»ƒä¸æ¨ç†</h1>
        
        <p>è¿™æ˜¯ä¸€ä¸ªå®Œæ•´çš„Transformeræ¶æ„äº¤äº’å¼æ¼”ç¤ºï¼ŒåŒ…å«ä½¿ç”¨å®é™…å¥å­çš„è®­ç»ƒå’Œæ¨ç†è¿‡ç¨‹ã€‚</p>

        <h2>ğŸ“š 1. æ•°æ®å‡†å¤‡ä¸è¯æ±‡è¡¨</h2>
        <div class="code-block">
            <pre>// è®­ç»ƒæ•°æ® - ç®€å•çš„ä¸­æ–‡å¥å­
const trainingSentences = [
    "æˆ‘å–œæ¬¢å­¦ä¹ ",
    "å­¦ä¹ å¾ˆæœ‰è¶£",
    "æˆ‘å–œæ¬¢ç¼–ç¨‹",
    "ç¼–ç¨‹å¾ˆæœ‰è¶£",
    "æ·±åº¦å­¦ä¹ å¾ˆå¼ºå¤§",
    "æˆ‘çˆ±å­¦ä¹ ",
    "å­¦ä¹ ä½¿æˆ‘å¿«ä¹",
    "ç¼–ç¨‹æ”¹å˜ä¸–ç•Œ"
];

// æ•°æ®ç‰¹ç‚¹ï¼š
// â€¢ åŒ…å«é‡å¤æ¨¡å¼ï¼ˆ"æˆ‘å–œæ¬¢"ã€"å¾ˆæœ‰è¶£"ï¼‰
// â€¢ çŸ­å¥ä¸ºä¸»ï¼ˆ4-7ä¸ªå­—ç¬¦ï¼‰
// â€¢ è¯æ±‡é‡å°ï¼ˆä¾¿äºå­¦ä¹ ï¼‰
// â€¢ ä¸»é¢˜ç›¸å…³ï¼ˆå­¦ä¹ ã€ç¼–ç¨‹ï¼‰</pre>
        </div>
        
        <div id="vocab-display" class="output"></div>

        <h2>ğŸ§  2. ç®€åŒ–çš„Transformeræ¨¡å‹</h2>
        <div class="code-block">
            <pre>class MiniTransformer {
    constructor(vocabSize, dModel = 32, nHeads = 2, nLayers = 2) {
        this.vocabSize = vocabSize;
        this.dModel = dModel;
        this.nHeads = nHeads;
        this.nLayers = nLayers;
        
        // åˆå§‹åŒ–å‚æ•°
        this.embedding = this.initMatrix(vocabSize, dModel);
        this.layers = [];
        for (let i = 0; i < nLayers; i++) {
            this.layers.push({
                Wq: this.initMatrix(dModel, dModel),
                Wk: this.initMatrix(dModel, dModel),
                Wv: this.initMatrix(dModel, dModel),
                Wo: this.initMatrix(dModel, dModel),
                ff1: this.initMatrix(dModel, dModel * 4),
                ff2: this.initMatrix(dModel * 4, dModel),
                norm1: {gamma: Array(dModel).fill(1), beta: Array(dModel).fill(0)},
                norm2: {gamma: Array(dModel).fill(1), beta: Array(dModel).fill(0)}
            });
        }
        this.outputProj = this.initMatrix(dModel, vocabSize);
    }
    
    attention(Q, K, V) {
        // Scaled Dot-Product Attention
        const dk = Math.sqrt(K[0].length);
        const scores = this.matmul(Q, this.transpose(K));
        
        // Scale
        for (let i = 0; i < scores.length; i++) {
            for (let j = 0; j < scores[i].length; j++) {
                scores[i][j] /= dk;
            }
        }
        
        // Causal mask
        for (let i = 0; i < scores.length; i++) {
            for (let j = i + 1; j < scores[i].length; j++) {
                scores[i][j] = -1e9;
            }
        }
        
        // Softmax
        const weights = this.softmax2D(scores);
        
        // Apply to values
        return this.matmul(weights, V);
    }
}</pre>
        </div>

        <h2>ğŸ¯ 3. è®­ç»ƒè¿‡ç¨‹æ¼”ç¤º</h2>
        <button onclick="startTraining()">å¼€å§‹è®­ç»ƒ</button>
        <button onclick="resetModel()">é‡ç½®æ¨¡å‹</button>
        
        <div class="progress-bar">
            <div id="training-progress" class="progress-fill" style="width: 0%"></div>
        </div>
        
        <div id="training-status" class="training-log">
            ç‚¹å‡»"å¼€å§‹è®­ç»ƒ"æŒ‰é’®å¼€å§‹è®­ç»ƒè¿‡ç¨‹...
        </div>
        
        <canvas id="loss-chart" width="600" height="300"></canvas>

        <h2>ğŸ”® 4. æ¨ç†ç”Ÿæˆæ¼”ç¤º</h2>
        <div>
            <label>è¾“å…¥å¼€å§‹æ–‡æœ¬ï¼š</label>
            <input type="text" id="seed-text" value="æˆ‘" style="padding: 5px; font-size: 16px;">
            <button onclick="generateText()">ç”Ÿæˆæ–‡æœ¬</button>
            <label>æœ€å¤§é•¿åº¦ï¼š</label>
            <input type="number" id="max-length" value="10" min="1" max="20" style="width: 60px; padding: 5px;">
        </div>
        
        <div id="generation-process" class="generation-step">
            <strong>ç”Ÿæˆè¿‡ç¨‹ï¼š</strong>
            <div id="generation-steps"></div>
        </div>
        
        <div id="generated-output" class="output">
            <strong>æœ€ç»ˆè¾“å‡ºï¼š</strong> <span id="final-text">ç­‰å¾…ç”Ÿæˆ...</span>
        </div>

        <h2>ğŸ“Š 5. æ³¨æ„åŠ›å¯è§†åŒ–</h2>
        <button onclick="visualizeAttention()">å¯è§†åŒ–æœ€åä¸€æ¬¡æ³¨æ„åŠ›</button>
        
        <div id="attention-viz"></div>

        <h2>ğŸ’¡ å…³é”®æ¦‚å¿µè¯´æ˜</h2>
        <div class="output">
            <h3>è®­ç»ƒè¿‡ç¨‹ï¼š</h3>
            <ul>
                <li><strong>Teacher Forcing</strong>ï¼šè®­ç»ƒæ—¶ä½¿ç”¨çœŸå®çš„ä¸‹ä¸€ä¸ªtokenä½œä¸ºç›®æ ‡</li>
                <li><strong>æŸå¤±è®¡ç®—</strong>ï¼šä½¿ç”¨äº¤å‰ç†µæŸå¤±ï¼Œè¡¡é‡é¢„æµ‹åˆ†å¸ƒä¸çœŸå®tokençš„å·®å¼‚</li>
                <li><strong>æ¢¯åº¦ä¸‹é™</strong>ï¼šé€šè¿‡åå‘ä¼ æ’­æ›´æ–°æ¨¡å‹å‚æ•°</li>
                <li><strong>ä¸ºä»€ä¹ˆæŸå¤±ä¼šæ³¢åŠ¨ï¼Ÿ</strong>
                    <ul>
                        <li>è¿™æ˜¯<strong>æ­£å¸¸ç°è±¡</strong>ï¼ç‰¹åˆ«æ˜¯åœ¨ç®€åŒ–çš„æ¼”ç¤ºç‰ˆæœ¬ä¸­</li>
                        <li>æ•°æ®é‡å°ï¼ˆåªæœ‰5ä¸ªå¥å­ï¼‰å¯¼è‡´è¿‡æ‹Ÿåˆé£é™©</li>
                        <li>æ¨¡å‹å®¹é‡æœ‰é™ï¼ˆåªæœ‰8ç»´éšè—çŠ¶æ€ï¼‰</li>
                        <li>éšæœºåˆå§‹åŒ–å’Œæ•°æ®æ‰“ä¹±ä¼šå¼•å…¥å˜åŒ–</li>
                        <li>å®é™…æ·±åº¦å­¦ä¹ ä¸­ä¹Ÿä¼šå‡ºç°æŸå¤±æ³¢åŠ¨ï¼Œé€šè¿‡æ›´å¤šæŠ€å·§ï¼ˆå¦‚å­¦ä¹ ç‡è°ƒåº¦ã€æ­£åˆ™åŒ–ç­‰ï¼‰æ¥ç¼“è§£</li>
                    </ul>
                </li>
            </ul>
            
            <h3>æ¨ç†è¿‡ç¨‹ï¼š</h3>
            <ul>
                <li><strong>è‡ªå›å½’ç”Ÿæˆ</strong>ï¼šæ¯æ¬¡é¢„æµ‹ä¸€ä¸ªtokenï¼Œå°†å…¶åŠ å…¥åºåˆ—ç»§ç»­é¢„æµ‹</li>
                <li><strong>è´ªå©ªè§£ç </strong>ï¼šé€‰æ‹©æ¦‚ç‡æœ€é«˜çš„tokenï¼ˆå¯æ”¹è¿›ä¸ºæŸæœç´¢ï¼‰</li>
                <li><strong>åœæ­¢æ¡ä»¶</strong>ï¼šé‡åˆ°[END]æ ‡è®°æˆ–è¾¾åˆ°æœ€å¤§é•¿åº¦</li>
                <li><strong>ä¸ºä»€ä¹ˆç”Ÿæˆå¾ˆçŸ­ï¼Ÿ</strong>
                    <ul>
                        <li>è®­ç»ƒæ•°æ®éƒ½æ˜¯çŸ­å¥ï¼ˆå¹³å‡4-6ä¸ªå­—ï¼‰</li>
                        <li>æ¨¡å‹å­¦ä¹ åˆ°äº†è¿™ç§é•¿åº¦åˆ†å¸ƒ</li>
                        <li>ç®€åŒ–çš„æ¨¡å‹æ¶æ„é™åˆ¶äº†ç”Ÿæˆèƒ½åŠ›</li>
                        <li>è¿™æ°å¥½å±•ç¤ºäº†æ¨¡å‹å¦‚ä½•å­¦ä¹ æ•°æ®çš„ç»Ÿè®¡è§„å¾‹ï¼</li>
                    </ul>
                </li>
            </ul>
            
            <h3>âš ï¸ æœŸæœ›ä¸ç°å®ï¼š</h3>
            <p style="background: #fffde7; padding: 10px; border-radius: 5px;">
                <strong>è¿™æ˜¯ä¸€ä¸ªæ•™å­¦æ¼”ç¤ºï¼š</strong><br>
                â€¢ ç›®æ ‡æ˜¯å±•ç¤ºTransformerçš„<strong>æ ¸å¿ƒåŸç†</strong>ï¼Œè€Œéå®ç°å®Œç¾çš„æ–‡æœ¬ç”Ÿæˆ<br>
                â€¢ çœŸå®çš„GPTæ¨¡å‹æœ‰æ•°åäº¿å‚æ•°ï¼Œè€Œæˆ‘ä»¬åªæœ‰å‡ ç™¾ä¸ª<br>
                â€¢ è®­ç»ƒæ•°æ®è§„æ¨¡å·®å¼‚ï¼šGPTç”¨TBçº§æ–‡æœ¬ï¼Œæˆ‘ä»¬ç”¨5ä¸ªå¥å­<br>
                â€¢ ä½†æ ¸å¿ƒæœºåˆ¶æ˜¯ç›¸åŒçš„ï¼šæ³¨æ„åŠ›æœºåˆ¶ã€è‡ªå›å½’ç”Ÿæˆã€æ¢¯åº¦ä¼˜åŒ–<br>
                â€¢ é€šè¿‡è¿™ä¸ªç®€åŒ–ç‰ˆæœ¬ï¼Œæ‚¨å¯ä»¥ç†è§£å¤§æ¨¡å‹çš„å·¥ä½œåŸç†ï¼
            </p>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let tokenizer;
        let model;
        let trainingSentences = [
            "æˆ‘å–œæ¬¢å­¦ä¹ ",
            "å­¦ä¹ å¾ˆæœ‰è¶£", 
            "æˆ‘å–œæ¬¢ç¼–ç¨‹",
            "ç¼–ç¨‹å¾ˆæœ‰è¶£",
            "æ·±åº¦å­¦ä¹ å¾ˆå¼ºå¤§",
            "æˆ‘çˆ±å­¦ä¹ ",
            "å­¦ä¹ ä½¿æˆ‘å¿«ä¹",
            "ç¼–ç¨‹æ”¹å˜ä¸–ç•Œ"
        ];
        let losses = [];
        let lastAttentionWeights = null;

        // åˆå§‹åŒ–
        function initialize() {
            console.log('å¼€å§‹åˆå§‹åŒ–...');
            
            // åˆå§‹åŒ–tokenizer
            tokenizer = new SimpleTokenizer();
            tokenizer.buildVocab(trainingSentences);
            
            // æ˜¾ç¤ºè¯æ±‡è¡¨
            const vocabDisplay = document.getElementById('vocab-display');
            vocabDisplay.innerHTML = `<strong>è¯æ±‡è¡¨å¤§å°ï¼š</strong>${tokenizer.vocabSize}<br>`;
            vocabDisplay.innerHTML += `<strong>è¯æ±‡ï¼š</strong>`;
            for (let [char, idx] of Object.entries(tokenizer.vocab)) {
                vocabDisplay.innerHTML += `<span class="token">${char}:${idx}</span>`;
            }
            
            // åˆ›å»ºç®€åŒ–çš„æ¨¡å‹
            model = new MiniTransformer(tokenizer.vocabSize);
            
            // æµ‹è¯•æ¨¡å‹æ˜¯å¦æ­£å¸¸å·¥ä½œ
            try {
                const testTokens = [tokenizer.vocab['[START]']];
                const testProbs = model.predict(testTokens);
                const probSum = testProbs.reduce((a, b) => a + b, 0);
                
                console.log('åˆå§‹åŒ–å®Œæˆ');
                console.log('è¯æ±‡è¡¨å¤§å°:', tokenizer.vocabSize);
                console.log('æ¨¡å‹æµ‹è¯• - æ¦‚ç‡å’Œ:', probSum.toFixed(4));
                console.log('æœ€å¤§æ¦‚ç‡token:', tokenizer.reverseVocab[testProbs.indexOf(Math.max(...testProbs))]);
                
                // éªŒè¯æ‰€æœ‰ç»„ä»¶
                console.log('ç»„ä»¶éªŒè¯:', {
                    tokenizerOK: tokenizer && tokenizer.vocab && tokenizer.reverseVocab,
                    modelOK: model && model.embedding && model.outputProj,
                    matricesOK: model && model.Wq && model.Wk && model.Wv
                });
            } catch (e) {
                console.error('åˆå§‹åŒ–æµ‹è¯•å¤±è´¥:', e);
            }
        }

        // SimpleTokenizerç±»
        class SimpleTokenizer {
            constructor() {
                this.vocab = {'[PAD]': 0, '[START]': 1, '[END]': 2};
                this.reverseVocab = {0: '[PAD]', 1: '[START]', 2: '[END]'};
                this.vocabSize = 3;
            }
            
            buildVocab(sentences) {
                for (let sentence of sentences) {
                    for (let char of sentence) {
                        if (!(char in this.vocab)) {
                            this.vocab[char] = this.vocabSize;
                            this.reverseVocab[this.vocabSize] = char;
                            this.vocabSize++;
                        }
                    }
                }
                console.log('è¯æ±‡è¡¨æ„å»ºå®Œæˆï¼Œå¤§å°:', this.vocabSize);
                console.log('è¯æ±‡:', Object.keys(this.vocab));
            }
            
            encode(text) {
                const chars = text.split('');
                const result = [this.vocab['[START]']];
                for (let char of chars) {
                    result.push(this.vocab[char] || 0);
                }
                result.push(this.vocab['[END]']);
                return result;
            }
            
            decode(tokens) {
                let result = '';
                for (let token of tokens) {
                    const char = this.reverseVocab[token];
                    if (char && char !== '[START]' && char !== '[END]' && char !== '[PAD]') {
                        result += char;
                    }
                }
                return result;
            }
        }

        // MiniTransformerç±»
        class MiniTransformer {
            constructor(vocabSize, dModel = 32, nHeads = 2, nLayers = 1) {
                this.vocabSize = vocabSize;
                this.dModel = dModel;
                this.nHeads = nHeads;
                this.nLayers = nLayers;
                this.dHead = Math.floor(dModel / nHeads);
                
                // æ”¹è¿›çš„å‚æ•°åˆå§‹åŒ–ï¼ˆXavieråˆå§‹åŒ–ï¼‰
                this.embedding = this.initMatrix(vocabSize, dModel, 0.1);
                this.outputProj = this.initMatrix(dModel, vocabSize, 0.1);
                
                this.layers = [];
                for (let i = 0; i < nLayers; i++) {
                    this.layers.push({
                        Wq: this.initMatrix(dModel, dModel, 0.1),
                        Wk: this.initMatrix(dModel, dModel, 0.1),
                        Wv: this.initMatrix(dModel, dModel, 0.1),
                        Wo: this.initMatrix(dModel, dModel, 0.1),
                        ff1: this.initMatrix(dModel, dModel * 2, 0.1),
                        ff2: this.initMatrix(dModel * 2, dModel, 0.1)
                    });
                }
            }
            
            initMatrix(rows, cols, scale = null) {
                const matrix = [];
                // Xavier/Glorotåˆå§‹åŒ–
                if (scale === null) {
                    scale = Math.sqrt(2.0 / (rows + cols));
                }
                for (let i = 0; i < rows; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < cols; j++) {
                        // ä½¿ç”¨æ­£æ€åˆ†å¸ƒè¿‘ä¼¼
                        let u1 = Math.random();
                        let u2 = Math.random();
                        let z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                        matrix[i][j] = z0 * scale;
                    }
                }
                return matrix;
            }
            
            forward(tokens) {
                // Embedding
                let x = [];
                for (let token of tokens) {
                    if (token < this.embedding.length) {
                        x.push([...this.embedding[token]]);
                    } else {
                        // å¦‚æœtokenè¶…å‡ºèŒƒå›´ï¼Œä½¿ç”¨éšæœºåˆå§‹åŒ–
                        x.push(new Array(this.dModel).fill(0).map(() => Math.random() * 0.1));
                    }
                }
                
                // æ·»åŠ ç®€å•çš„ä½ç½®ç¼–ç 
                for (let i = 0; i < x.length; i++) {
                    for (let j = 0; j < x[i].length; j++) {
                        x[i][j] += Math.sin(i / 10000 ** (2 * j / this.dModel)) * 0.1;
                    }
                }
                
                // Transformer layers
                for (let layer of this.layers) {
                    x = this.transformerLayer(x, layer);
                }
                
                // Output projection
                const output = [];
                for (let vec of x) {
                    const out = this.matmulVec(this.outputProj, vec);
                    output.push(out);
                }
                
                return output;
            }
            
            transformerLayer(x, layer) {
                // Multi-head attention
                const Q = this.matmul(x, this.transpose(layer.Wq));
                const K = this.matmul(x, this.transpose(layer.Wk));
                const V = this.matmul(x, this.transpose(layer.Wv));
                
                const attnOutput = this.attention(Q, K, V);
                lastAttentionWeights = this.lastAttentionWeights;
                
                // Add & Norm (simplified) - ä½¿ç”¨æ®‹å·®è¿æ¥
                let x1 = this.add(x, attnOutput);
                x1 = this.layerNorm(x1);
                
                // FFN
                let ffn = this.matmul(x1, this.transpose(layer.ff1));
                ffn = this.relu(ffn);
                ffn = this.matmul(ffn, this.transpose(layer.ff2));
                
                // Add & Norm (simplified)
                let x2 = this.add(x1, ffn);
                x2 = this.layerNorm(x2);
                
                return x2;
            }
            
            layerNorm(x) {
                // ç®€å•çš„å±‚å½’ä¸€åŒ–
                const result = [];
                for (let i = 0; i < x.length; i++) {
                    const vec = x[i];
                    const mean = vec.reduce((a, b) => a + b, 0) / vec.length;
                    const variance = vec.reduce((a, b) => a + (b - mean) ** 2, 0) / vec.length;
                    const std = Math.sqrt(variance + 1e-5);
                    
                    result[i] = vec.map(v => (v - mean) / std);
                }
                return result;
            }
            
            attention(Q, K, V) {
                const seqLen = Q.length;
                const dk = Math.sqrt(K[0].length) || 1;
                
                // QK^T
                const scores = this.matmul(Q, this.transpose(K));
                
                // Scale - ä½¿ç”¨æ›´ä¿å®ˆçš„ç¼©æ”¾
                for (let i = 0; i < scores.length; i++) {
                    for (let j = 0; j < scores[i].length; j++) {
                        scores[i][j] = scores[i][j] / (dk * 2); // æ›´ä¿å®ˆçš„ç¼©æ”¾
                    }
                }
                
                // Causal mask - ä½¿ç”¨æ›´å°çš„è´Ÿå€¼
                for (let i = 0; i < scores.length; i++) {
                    for (let j = i + 1; j < scores[i].length; j++) {
                        scores[i][j] = -100; // ä½¿ç”¨-100è€Œä¸æ˜¯-1e9
                    }
                }
                
                // Softmax
                const weights = [];
                for (let i = 0; i < scores.length; i++) {
                    weights[i] = this.softmax(scores[i]);
                }
                
                this.lastAttentionWeights = weights;
                
                // Apply to values
                return this.matmul(weights, V);
            }
            
            predict(tokens) {
                if (!tokens || tokens.length === 0) {
                    // è¿”å›å‡åŒ€åˆ†å¸ƒ
                    return new Array(this.vocabSize).fill(1 / this.vocabSize);
                }
                
                const output = this.forward(tokens);
                const lastOutput = output[output.length - 1];
                
                // æ£€æŸ¥è¾“å‡ºæ˜¯å¦æœ‰æ•ˆ
                if (!lastOutput || lastOutput.some(x => isNaN(x) || !isFinite(x))) {
                    console.warn('Invalid output, returning uniform distribution');
                    return new Array(this.vocabSize).fill(1 / this.vocabSize);
                }
                
                const probs = this.softmax(lastOutput);
                
                // å†æ¬¡æ£€æŸ¥æ¦‚ç‡æ˜¯å¦æœ‰æ•ˆ
                if (probs.some(x => isNaN(x)) || Math.abs(probs.reduce((a, b) => a + b, 0) - 1) > 0.01) {
                    console.warn('Invalid probabilities, returning uniform distribution');
                    return new Array(this.vocabSize).fill(1 / this.vocabSize);
                }
                
                return probs;
            }
            
            // è¾…åŠ©å‡½æ•°
            matmul(A, B) {
                const result = [];
                for (let i = 0; i < A.length; i++) {
                    result[i] = [];
                    for (let j = 0; j < B[0].length; j++) {
                        let sum = 0;
                        for (let k = 0; k < B.length; k++) {
                            const val = (A[i][k] || 0) * (B[k][j] || 0);
                            if (!isNaN(val) && isFinite(val)) {
                                sum += val;
                            }
                        }
                        result[i][j] = sum;
                    }
                }
                return result;
            }
            
            matmulVec(matrix, vec) {
                const result = [];
                for (let i = 0; i < matrix.length; i++) {
                    let sum = 0;
                    for (let j = 0; j < vec.length; j++) {
                        const val = (matrix[i][j] || 0) * (vec[j] || 0);
                        if (!isNaN(val) && isFinite(val)) {
                            sum += val;
                        }
                    }
                    result[i] = sum;
                }
                return result;
            }
            
            transpose(matrix) {
                if (!matrix || matrix.length === 0) return [];
                const result = [];
                for (let j = 0; j < matrix[0].length; j++) {
                    result[j] = [];
                    for (let i = 0; i < matrix.length; i++) {
                        result[j][i] = matrix[i][j] || 0;
                    }
                }
                return result;
            }
            
            add(A, B) {
                const result = [];
                for (let i = 0; i < A.length; i++) {
                    result[i] = [];
                    for (let j = 0; j < A[i].length; j++) {
                        const val = (A[i][j] || 0) + (B[i][j] || 0);
                        result[i][j] = isNaN(val) ? 0 : val;
                    }
                }
                return result;
            }
            
            relu(matrix) {
                const result = [];
                for (let i = 0; i < matrix.length; i++) {
                    result[i] = [];
                    for (let j = 0; j < matrix[i].length; j++) {
                        const val = matrix[i][j] || 0;
                        result[i][j] = Math.max(0, Math.min(10, val)); // é™åˆ¶æœ€å¤§å€¼é¿å…çˆ†ç‚¸
                    }
                }
                return result;
            }
            
            softmax(vec) {
                // æ•°å€¼ç¨³å®šçš„softmaxå®ç°
                const max = Math.max(...vec.filter(x => !isNaN(x) && isFinite(x)));
                const exp = vec.map(x => {
                    const val = x - max;
                    // é˜²æ­¢æç«¯å€¼
                    if (val < -20) return 0;
                    if (val > 20) return Math.exp(20);
                    return Math.exp(val);
                });
                const sum = exp.reduce((a, b) => a + b, 0) || 1;
                return exp.map(x => x / sum);
            }
            
            crossEntropyLoss(probs, targetIdx) {
                // ç¡®ä¿æ¦‚ç‡å€¼æœ‰æ•ˆ
                const prob = probs[targetIdx];
                if (isNaN(prob) || prob <= 0) {
                    return 10; // è¿”å›ä¸€ä¸ªå¤§çš„æŸå¤±å€¼è€Œä¸æ˜¯NaN
                }
                return -Math.log(Math.max(prob, 1e-10));
            }
        }

        // è®­ç»ƒå‡½æ•° - ç®€åŒ–ç‰ˆ
        async function startTraining() {
            const statusDiv = document.getElementById('training-status');
            const progressBar = document.getElementById('training-progress');
            losses = [];
            
            const epochs = 150; // æ›´å¤šè½®æ•°
            let learningRate = 0.1; // è¾ƒå¤§çš„åˆå§‹å­¦ä¹ ç‡
            
            for (let epoch = 0; epoch < epochs; epoch++) {
                let epochLoss = 0;
                let numSamples = 0;
                
                // éšæœºæ‰“ä¹±è®­ç»ƒæ•°æ®
                const shuffled = [...trainingSentences].sort(() => Math.random() - 0.5);
                
                for (let sentence of shuffled) {
                    const tokens = tokenizer.encode(sentence);
                    
                    for (let i = 0; i < tokens.length - 1; i++) {
                        const inputTokens = tokens.slice(0, i + 1);
                        const targetToken = tokens[i + 1];
                        
                        // Forward pass
                        const probs = model.predict(inputTokens);
                        const loss = model.crossEntropyLoss(probs, targetToken);
                        
                        if (!isNaN(loss) && isFinite(loss)) {
                            epochLoss += loss;
                            numSamples++;
                            
                            // è®¡ç®—æ¢¯åº¦å¹¶æ›´æ–°æƒé‡
                            // 1. æ›´æ–°è¾“å‡ºå±‚ï¼ˆæœ€é‡è¦ï¼‰
                            const outputGrad = [...probs];
                            outputGrad[targetToken] -= 1; // äº¤å‰ç†µæ¢¯åº¦
                            
                            // æ›´æ–°outputProjçŸ©é˜µçš„å¯¹åº”è¡Œ
                            for (let k = 0; k < model.vocabSize; k++) {
                                if (model.outputProj[k]) {
                                    for (let j = 0; j < model.dModel; j++) {
                                        if (model.outputProj[k][j] !== undefined) {
                                            model.outputProj[k][j] -= learningRate * outputGrad[k] * 0.01;
                                            // æƒé‡è£å‰ª
                                            model.outputProj[k][j] = Math.max(-3, Math.min(3, model.outputProj[k][j]));
                                        }
                                    }
                                }
                            }
                            
                            // 2. æ›´æ–°embedding
                            for (let tid of inputTokens) {
                                if (tid >= 0 && tid < model.embedding.length) {
                                    for (let j = 0; j < model.dModel; j++) {
                                        if (model.embedding[tid] && model.embedding[tid][j] !== undefined) {
                                            // ç®€å•çš„æ¢¯åº¦ä¼°è®¡
                                            const grad = outputGrad[targetToken] * (Math.random() - 0.5) * 0.1;
                                            model.embedding[tid][j] -= learningRate * grad;
                                            model.embedding[tid][j] = Math.max(-3, Math.min(3, model.embedding[tid][j]));
                                        }
                                    }
                                }
                            }
                            
                            // 3. æ›´æ–°æ³¨æ„åŠ›æƒé‡ï¼ˆå¶å°”ï¼‰
                            if (Math.random() < 0.1) {
                                const matrices = [model.Wq, model.Wk, model.Wv];
                                const matrix = matrices[Math.floor(Math.random() * matrices.length)];
                                if (matrix && matrix.length > 0 && matrix[0]) {
                                    const i = Math.floor(Math.random() * matrix.length);
                                    const j = Math.floor(Math.random() * matrix[0].length);
                                    if (matrix[i] && matrix[i][j] !== undefined) {
                                        matrix[i][j] -= learningRate * outputGrad[targetToken] * (Math.random() - 0.5) * 0.01;
                                        matrix[i][j] = Math.max(-3, Math.min(3, matrix[i][j]));
                                    }
                                }
                            }
                        }
                    }
                }
                
                // è®¡ç®—å¹³å‡æŸå¤±
                const avgLoss = numSamples > 0 ? epochLoss / numSamples : 10;
                losses.push(avgLoss);
                
                // å­¦ä¹ ç‡è¡°å‡
                if (epoch > 50) {
                    learningRate *= 0.995;
                }
                
                // æ›´æ–°UI
                progressBar.style.width = ((epoch + 1) / epochs * 100) + '%';
                statusDiv.innerHTML = `<strong>è®­ç»ƒä¸­...</strong><br>`;
                statusDiv.innerHTML += `Epoch ${epoch + 1}/${epochs}<br>`;
                statusDiv.innerHTML += `Loss: ${avgLoss.toFixed(4)}<br>`;
                statusDiv.innerHTML += `å­¦ä¹ ç‡: ${learningRate.toFixed(5)}`;
                
                // æ¯20è½®æ˜¾ç¤ºæµ‹è¯•
                if ((epoch + 1) % 30 === 0) {
                    const testPrompt = 'æˆ‘';
                    const testTokens = tokenizer.encode(testPrompt);
                    const testProbs = model.predict(testTokens.slice(0, -1));
                    const topProbs = [...testProbs]
                        .map((p, i) => ({p, i}))
                        .sort((a, b) => b.p - a.p)
                        .slice(0, 3);
                    
                    statusDiv.innerHTML += '<br><strong>æµ‹è¯•ç”Ÿæˆ:</strong><br>';
                    statusDiv.innerHTML += `"${testPrompt}" â†’ `;
                    for (let {p, i} of topProbs) {
                        const char = tokenizer.reverseVocab[i] || '?';
                        statusDiv.innerHTML += `${char}(${(p*100).toFixed(1)}%) `;
                    }
                }
                
                // ç»˜åˆ¶æŸå¤±å›¾
                drawLossChart();
                
                // å¼‚æ­¥å»¶è¿Ÿ
                await new Promise(resolve => setTimeout(resolve, 5));
            }
            
            statusDiv.innerHTML = `<strong>è®­ç»ƒå®Œæˆï¼</strong><br>`;
            statusDiv.innerHTML += `æœ€ç»ˆæŸå¤±: ${losses[losses.length - 1].toFixed(4)}`;
        }

        // æ–‡æœ¬ç”Ÿæˆå‡½æ•° - æ”¹è¿›ç‰ˆï¼ŒåŒ…å«è§£é‡Š
        async function generateText() {
            const seedText = document.getElementById('seed-text').value;
            const maxLength = parseInt(document.getElementById('max-length').value);
            const stepsDiv = document.getElementById('generation-steps');
            const finalTextSpan = document.getElementById('final-text');
            
            stepsDiv.innerHTML = `<div style="background: #f0f8ff; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                <strong>ğŸ¤– ç”ŸæˆåŸç†ï¼š</strong><br>
                <span style="font-size: 12px; color: #666;">
                â€¢ è‡ªå›å½’ç”Ÿæˆï¼šæ¯æ¬¡é¢„æµ‹ä¸€ä¸ªå­—ç¬¦<br>
                â€¢ ä½¿ç”¨å·²ç”Ÿæˆçš„å†…å®¹ä½œä¸ºä¸Šä¸‹æ–‡<br>
                â€¢ é€‰æ‹©æ¦‚ç‡æœ€é«˜çš„å­—ç¬¦ï¼ˆè´ªå©ªè§£ç ï¼‰<br>
                â€¢ é‡åˆ°[END]æˆ–è¾¾åˆ°æœ€å¤§é•¿åº¦æ—¶åœæ­¢<br>
                </span>
            </div>`;
            
            // æ„å»ºåˆå§‹tokensï¼ˆé‡è¦ï¼šä¸åŒ…å«[END]ï¼‰
            let tokens = [];
            if (seedText) {
                // æ‰‹åŠ¨æ„å»ºtokensï¼Œé¿å…åŒ…å«[END]
                tokens.push(tokenizer.vocab['[START]']);
                for (let char of seedText) {
                    if (tokenizer.vocab[char] !== undefined) {
                        tokens.push(tokenizer.vocab[char]);
                    }
                }
            } else {
                tokens = [tokenizer.vocab['[START]']];
            }
            
            let generatedText = seedText;
            let consecutiveEndCount = 0; // è®°å½•è¿ç»­é¢„æµ‹ENDçš„æ¬¡æ•°
            
            console.log('å¼€å§‹ç”Ÿæˆï¼Œåˆå§‹tokens:', tokens);
            console.log('åˆå§‹æ–‡æœ¬:', generatedText);
            
            for (let step = 0; step < maxLength; step++) {
                // é¢„æµ‹ä¸‹ä¸€ä¸ªtoken
                const probs = model.predict(tokens);
                
                // æ£€æŸ¥æ¦‚ç‡æ˜¯å¦æœ‰æ•ˆ
                if (!probs || probs.every(p => isNaN(p))) {
                    stepsDiv.innerHTML += '<div style="color: red;">âŒ æ¨¡å‹é¢„æµ‹å¤±è´¥ï¼Œè¯·å…ˆè®­ç»ƒæ¨¡å‹</div>';
                    break;
                }
                
                // è·å–top-kå€™é€‰ï¼ˆæ’é™¤ç‰¹æ®Šæ ‡è®°ï¼‰
                const candidates = [];
                for (let i = 0; i < probs.length; i++) {
                    const token = tokenizer.reverseVocab[i];
                    // è¿‡æ»¤ç‰¹æ®Šæ ‡è®°ï¼Œä½†ä¿ç•™[END]ç”¨äºåˆ¤æ–­
                    if (token && token !== '[PAD]' && token !== '[START]') {
                        candidates.push({
                            idx: i,
                            prob: probs[i],
                            token: token
                        });
                    }
                }
                
                // æŒ‰æ¦‚ç‡æ’åº
                candidates.sort((a, b) => b.prob - a.prob);
                
                // é€‰æ‹©ç­–ç•¥ï¼šå¦‚æœ[END]æ¦‚ç‡è¿‡é«˜ä¸”å·²ç”Ÿæˆè¶³å¤Ÿå†…å®¹ï¼Œè€ƒè™‘ç»“æŸ
                let nextToken = candidates[0].idx;
                let selectedToken = candidates[0].token;
                
                // å¦‚æœæ¨¡å‹å¼ºçƒˆå€¾å‘äº[END]ï¼ˆæ¦‚ç‡>60%ï¼‰ä¸”å·²ç”Ÿæˆè‡³å°‘2ä¸ªå­—ç¬¦
                if (selectedToken === '[END]' && candidates[0].prob > 0.6 && generatedText.length >= 2) {
                    consecutiveEndCount++;
                    if (consecutiveEndCount >= 1) {
                        stepsDiv.innerHTML += `<div style="color: #2196f3;">
                            æ­¥éª¤ ${step + 1}: æ¨¡å‹é¢„æµ‹[END]æ ‡è®°(${(candidates[0].prob * 100).toFixed(1)}%)ï¼Œç”Ÿæˆç»“æŸ
                        </div>`;
                        break;
                    }
                } else if (selectedToken === '[END]') {
                    // å¦‚æœå¤ªæ—©é‡åˆ°[END]ï¼Œé€‰æ‹©æ¬¡ä¼˜é€‰é¡¹
                    if (generatedText.length < 2 && candidates.length > 1) {
                        nextToken = candidates[1].idx;
                        selectedToken = candidates[1].token;
                        consecutiveEndCount = 0;
                    } else {
                        stepsDiv.innerHTML += `<div style="color: #2196f3;">
                            æ­¥éª¤ ${step + 1}: é‡åˆ°[END]æ ‡è®°ï¼Œç”Ÿæˆç»“æŸ
                        </div>`;
                        break;
                    }
                } else {
                    consecutiveEndCount = 0;
                }
                
                // æ˜¾ç¤ºç”Ÿæˆæ­¥éª¤
                let stepHtml = `<div style="border-left: 3px solid #4caf50; padding-left: 10px; margin: 5px 0;">`;
                stepHtml += `<strong>æ­¥éª¤ ${step + 1}:</strong><br>`;
                stepHtml += `å½“å‰æ–‡æœ¬: <span class="token" style="background: #e8f5e9;">${generatedText || '[ç©º]'}</span><br>`;
                stepHtml += `é¢„æµ‹åˆ†å¸ƒ: `;
                
                // æ˜¾ç¤ºtop-5å€™é€‰
                const topCandidates = candidates.slice(0, 5);
                for (let i = 0; i < topCandidates.length; i++) {
                    const cand = topCandidates[i];
                    const isSelected = (cand.idx === nextToken);
                    const bgColor = isSelected ? '#ffeb3b' : '#f0f0f0';
                    const fontWeight = isSelected ? 'bold' : 'normal';
                    
                    stepHtml += `<span class="token" style="background: ${bgColor}; font-weight: ${fontWeight};">`;
                    stepHtml += `${cand.token}(${(cand.prob * 100).toFixed(1)}%)`;
                    stepHtml += `</span> `;
                }
                
                if (selectedToken !== '[END]') {
                    stepHtml += `<br>é€‰æ‹©: <strong>${selectedToken}</strong>`;
                }
                stepHtml += '</div>';
                stepsDiv.innerHTML += stepHtml;
                
                // å¦‚æœä¸æ˜¯[END]ï¼Œæ·»åŠ åˆ°åºåˆ—
                if (selectedToken !== '[END]') {
                    tokens.push(nextToken);
                    generatedText += selectedToken;
                }
                
                // æ¨¡æ‹Ÿå¼‚æ­¥ï¼Œè®©ç”¨æˆ·çœ‹åˆ°ç”Ÿæˆè¿‡ç¨‹
                await new Promise(resolve => setTimeout(resolve, 300));
            }
            
            // æ˜¾ç¤ºæœ€ç»ˆç»“æœ
            finalTextSpan.innerHTML = `<strong>${generatedText || '(ç©º)'}</strong>`;
            
            // æ·»åŠ è§£é‡Š
            if (generatedText.length <= 2) {
                stepsDiv.innerHTML += `<div style="background: #fff3e0; padding: 10px; border-radius: 5px; margin-top: 10px;">
                    <strong>ğŸ’¡ è¯´æ˜ï¼š</strong><br>
                    <span style="font-size: 12px;">
                    ç”Ÿæˆè¾ƒçŸ­å¯èƒ½æ˜¯å› ä¸ºï¼š<br>
                    â€¢ æ¨¡å‹å­¦åˆ°äº†è®­ç»ƒæ•°æ®çš„é•¿åº¦æ¨¡å¼<br>
                    â€¢ è®­ç»ƒæ•°æ®ä¸­çš„å¥å­éƒ½æ¯”è¾ƒçŸ­<br>
                    â€¢ æ¨¡å‹å®¹é‡æœ‰é™ï¼ˆåªæœ‰8ç»´ï¼‰<br>
                    â€¢ å¯ä»¥å°è¯•ä¸åŒçš„æç¤ºè¯æˆ–å¢åŠ è®­ç»ƒ<br>
                    </span>
                </div>`;
            }
            
            console.log('ç”Ÿæˆå®Œæˆ:', generatedText);
        }

        // ç»˜åˆ¶æŸå¤±å›¾
        function drawLossChart() {
            const canvas = document.getElementById('loss-chart');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (losses.length === 0) return;
            
            // è¿‡æ»¤æ‰æ— æ•ˆå€¼
            const validLosses = losses.filter(l => !isNaN(l) && isFinite(l));
            if (validLosses.length === 0) return;
            
            const padding = 40;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            const maxLoss = Math.min(Math.max(...validLosses), 10); // é™åˆ¶æœ€å¤§å€¼ä¸º10
            const minLoss = Math.max(Math.min(...validLosses), 0);
            
            // ç»˜åˆ¶åæ ‡è½´
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            // ç»˜åˆ¶æŸå¤±æ›²çº¿
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            let firstValid = true;
            for (let i = 0; i < losses.length; i++) {
                if (isNaN(losses[i]) || !isFinite(losses[i])) continue;
                
                const x = padding + (i / (losses.length - 1 || 1)) * width;
                const lossValue = Math.min(losses[i], maxLoss);
                const y = canvas.height - padding - ((lossValue - minLoss) / (maxLoss - minLoss || 1)) * height;
                
                if (firstValid) {
                    ctx.moveTo(x, y);
                    firstValid = false;
                } else {
                    ctx.lineTo(x, y);
                }
                
                // ç»˜åˆ¶ç‚¹
                ctx.fillStyle = '#764ba2';
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            ctx.stroke();
            
            // æ·»åŠ æ ‡ç­¾
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('Loss', 10, 20);
            ctx.fillText('Epoch', canvas.width - 50, canvas.height - 10);
            
            // æ·»åŠ æ•°å€¼æ ‡ç­¾
            ctx.font = '12px Arial';
            ctx.fillText(maxLoss.toFixed(2), 5, padding);
            ctx.fillText(minLoss.toFixed(2), 5, canvas.height - padding);
        }

        // æ³¨æ„åŠ›å¯è§†åŒ–
        function visualizeAttention() {
            if (!lastAttentionWeights || lastAttentionWeights.length === 0) {
                alert('è¯·å…ˆè¿›è¡Œä¸€æ¬¡æ–‡æœ¬ç”Ÿæˆï¼');
                return;
            }
            
            const vizDiv = document.getElementById('attention-viz');
            vizDiv.innerHTML = '<h3>æ³¨æ„åŠ›æƒé‡çŸ©é˜µ</h3>';
            
            const weights = lastAttentionWeights;
            const size = Math.min(weights.length, 10); // é™åˆ¶æ˜¾ç¤ºå¤§å°
            
            // åˆ›å»ºçƒ­åŠ›å›¾
            let html = '<div style="display: inline-block; background: #f5f5f5; padding: 10px; border-radius: 8px;">';
            
            for (let i = 0; i < size; i++) {
                html += '<div style="display: flex;">';
                for (let j = 0; j < size; j++) {
                    let value = 0;
                    if (i < weights.length && j < weights[i].length) {
                        value = weights[i][j];
                        // ç¡®ä¿å€¼æœ‰æ•ˆ
                        if (isNaN(value) || !isFinite(value)) {
                            value = 0;
                        }
                    }
                    
                    const intensity = Math.floor(Math.min(Math.max(value, 0), 1) * 255);
                    const color = `rgb(${255 - intensity}, ${255 - intensity * 0.5}, 255)`;
                    html += `<div class="attention-cell" style="background: ${color};">${(value * 100).toFixed(0)}</div>`;
                }
                html += '</div>';
            }
            
            html += '</div>';
            html += '<p style="margin-top: 10px; color: #666;">æ˜¾ç¤ºå‰' + size + 'Ã—' + size + 'ä¸ªä½ç½®çš„æ³¨æ„åŠ›æƒé‡</p>';
            vizDiv.innerHTML += html;
        }

        // é‡ç½®æ¨¡å‹
        function resetModel() {
            console.log('é‡ç½®æ¨¡å‹...');
            
            try {
                // é‡æ–°åˆå§‹åŒ–tokenizerå’Œæ¨¡å‹
                tokenizer = new SimpleTokenizer();
                tokenizer.buildVocab(trainingSentences);
                
                // æ˜¾ç¤ºè¯æ±‡è¡¨
                const vocabDisplay = document.getElementById('vocab-display');
                vocabDisplay.innerHTML = `<strong>è¯æ±‡è¡¨å¤§å°ï¼š</strong>${tokenizer.vocabSize}<br>`;
                vocabDisplay.innerHTML += `<strong>è¯æ±‡ï¼š</strong>`;
                for (let [char, idx] of Object.entries(tokenizer.vocab)) {
                    vocabDisplay.innerHTML += `<span class="token">${char}:${idx}</span>`;
                }
                
                // ä½¿ç”¨ç®€åŒ–çš„æ¨¡å‹
                model = new MiniTransformer(tokenizer.vocabSize);
                
                // æµ‹è¯•æ¨¡å‹
                const testTokens = [tokenizer.vocab['[START]']];
                const testProbs = model.predict(testTokens);
                const probSum = testProbs.reduce((a, b) => a + b, 0);
                
                losses = [];
                lastAttentionWeights = null;
                document.getElementById('training-progress').style.width = '0%';
                document.getElementById('training-status').innerHTML = 'æ¨¡å‹å·²é‡ç½®ï¼Œç‚¹å‡»"å¼€å§‹è®­ç»ƒ"æŒ‰é’®å¼€å§‹è®­ç»ƒè¿‡ç¨‹...';
                document.getElementById('training-status').innerHTML += `<br>æ¨¡å‹æµ‹è¯•: æ¦‚ç‡å’Œ=${probSum.toFixed(4)}`;
                drawLossChart();
                document.getElementById('final-text').textContent = 'ç­‰å¾…ç”Ÿæˆ...';
                document.getElementById('generation-steps').innerHTML = '';
                
                console.log('æ¨¡å‹å·²é‡ç½®ï¼Œè¯æ±‡è¡¨å¤§å°:', tokenizer.vocabSize);
            } catch (e) {
                console.error('é‡ç½®æ¨¡å‹å¤±è´¥:', e);
                alert('é‡ç½®æ¨¡å‹å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢');
            }
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        window.onload = function() {
            try {
                initialize();
                drawLossChart();
                console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œç³»ç»Ÿå·²åˆå§‹åŒ–');
            } catch (e) {
                console.error('é¡µé¢åˆå§‹åŒ–å¤±è´¥:', e);
                alert('åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
            }
        };
    </script>
</body>
</html>
