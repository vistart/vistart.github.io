<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gRPC Calculator Demo</title>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1, h2 {
            color: #4fc3f7;
            border-bottom: 2px solid #4fc3f7;
            padding-bottom: 10px;
        }
        .file-section {
            background: #2d2d2d;
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
            border: 1px solid #404040;
        }
        .file-header {
            background: #404040;
            padding: 12px 20px;
            color: #fff;
            font-weight: bold;
            display: flex;
            align-items: center;
        }
        .file-icon {
            margin-right: 10px;
            font-size: 18px;
        }
        .code-content {
            padding: 20px;
            background: #1e1e1e;
            overflow-x: auto;
        }
        pre {
            margin: 0;
            font-size: 14px;
            line-height: 1.5;
        }
        .command-section {
            background: #0d47a1;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .step {
            background: #2e7d32;
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-weight: bold;
        }
        .keyword { color: #ff7043; }
        .string { color: #66bb6a; }
        .comment { color: #616161; font-style: italic; }
        .function { color: #42a5f5; }
        .number { color: #ab47bc; }
        
        .demo-controls {
            background: #424242;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .demo-controls button {
            background: #4fc3f7;
            color: #1a1a1a;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-weight: bold;
        }
        .demo-controls button:hover {
            background: #29b6f6;
        }
        .output {
            background: #1a1a1a;
            border: 1px solid #404040;
            padding: 15px;
            border-radius: 6px;
            margin-top: 10px;
            min-height: 100px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🚀 gRPC Calculator Service - Python3 Complete Demo</h1>
        
        <div class="step">步骤 1: 定义Protocol Buffer服务接口</div>
        
        <div class="file-section">
            <div class="file-header">
                <span class="file-icon">📄</span>
                calculator_enhanced.proto - 强类型约束版本
            </div>
            <div class="code-content">
                <pre><code><span class="comment">// Protocol Buffer 定义文件 - 增强类型约束版本</span>
<span class="keyword">syntax</span> = <span class="string">"proto3"</span>;

<span class="keyword">package</span> calculator.v2;

<span class="keyword">import</span> <span class="string">"google/protobuf/timestamp.proto"</span>;

<span class="comment">// ============== 枚举类型定义 ==============</span>

<span class="comment">// 操作类型枚举 - 强类型约束</span>
<span class="keyword">enum</span> <span class="function">OperationType</span> {
    OPERATION_UNSPECIFIED = <span class="number">0</span>;  <span class="comment">// 默认值，用于检测未设置的操作</span>
    OPERATION_ADD = <span class="number">1</span>;
    OPERATION_SUBTRACT = <span class="number">2</span>;
    OPERATION_MULTIPLY = <span class="number">3</span>;
    OPERATION_DIVIDE = <span class="number">4</span>;
    OPERATION_POWER = <span class="number">5</span>;
    OPERATION_SQRT = <span class="number">6</span>;
    OPERATION_MODULO = <span class="number">7</span>;
}

<span class="comment">// 数字精度类型</span>
<span class="keyword">enum</span> <span class="function">Precision</span> {
    PRECISION_STANDARD = <span class="number">0</span>;    <span class="comment">// 标准精度</span>
    PRECISION_HIGH = <span class="number">1</span>;        <span class="comment">// 高精度</span>
    PRECISION_SCIENTIFIC = <span class="number">2</span>;  <span class="comment">// 科学计数法</span>
}

<span class="comment">// 错误类型枚举</span>
<span class="keyword">enum</span> <span class="function">ErrorCode</span> {
    ERROR_NONE = <span class="number">0</span>;
    ERROR_DIVISION_BY_ZERO = <span class="number">1</span>;
    ERROR_INVALID_OPERATION = <span class="number">2</span>;
    ERROR_NUMBER_TOO_LARGE = <span class="number">3</span>;
    ERROR_NUMBER_TOO_SMALL = <span class="number">4</span>;
    ERROR_NEGATIVE_SQRT = <span class="number">5</span>;
    ERROR_OVERFLOW = <span class="number">6</span>;
    ERROR_UNDERFLOW = <span class="number">7</span>;
}

<span class="comment">// ============== 服务定义 ==============</span>

<span class="keyword">service</span> <span class="function">CalculatorV2</span> {
    <span class="comment">// 基本二元运算</span>
    <span class="keyword">rpc</span> <span class="function">Calculate</span>(<span class="function">CalculationRequest</span>) <span class="keyword">returns</span> (<span class="function">CalculationResponse</span>);
    
    <span class="comment">// 批量计算</span>
    <span class="keyword">rpc</span> <span class="function">BatchCalculate</span>(<span class="function">BatchCalculationRequest</span>) <span class="keyword">returns</span> (<span class="function">BatchCalculationResponse</span>);
    
    <span class="comment">// 流式计算</span>
    <span class="keyword">rpc</span> <span class="function">StreamCalculate</span>(<span class="keyword">stream</span> <span class="function">CalculationRequest</span>) <span class="keyword">returns</span> (<span class="keyword">stream</span> <span class="function">CalculationResponse</span>);
    
    <span class="comment">// 获取服务器能力</span>
    <span class="keyword">rpc</span> <span class="function">GetCapabilities</span>(<span class="function">CapabilitiesRequest</span>) <span class="keyword">returns</span> (<span class="function">CapabilitiesResponse</span>);
    
    <span class="comment">// 验证表达式</span>
    <span class="keyword">rpc</span> <span class="function">ValidateExpression</span>(<span class="function">ValidationRequest</span>) <span class="keyword">returns</span> (<span class="function">ValidationResponse</span>);
}

<span class="comment">// ============== 请求和响应消息 ==============</span>

<span class="comment">// 计算请求 - 包含类型约束和验证</span>
<span class="keyword">message</span> <span class="function">CalculationRequest</span> {
    <span class="comment">// 操作数 - 使用oneof确保类型安全</span>
    <span class="keyword">oneof</span> operand_a {
        <span class="keyword">double</span> number_a = <span class="number">1</span>;
        <span class="keyword">string</span> decimal_a = <span class="number">2</span>;  <span class="comment">// 高精度十进制字符串</span>
    }
    
    <span class="keyword">oneof</span> operand_b {
        <span class="keyword">double</span> number_b = <span class="number">3</span>;
        <span class="keyword">string</span> decimal_b = <span class="number">4</span>;  <span class="comment">// 高精度十进制字符串</span>
    }
    
    <span class="comment">// 操作类型 - 强类型枚举</span>
    <span class="function">OperationType</span> operation = <span class="number">5</span>;
    
    <span class="comment">// 计算配置</span>
    <span class="function">CalculationConfig</span> config = <span class="number">6</span>;
    
    <span class="comment">// 请求元数据</span>
    <span class="function">RequestMetadata</span> metadata = <span class="number">7</span>;
}

<span class="comment">// 计算配置</span>
<span class="keyword">message</span> <span class="function">CalculationConfig</span> {
    <span class="comment">// 精度设置</span>
    <span class="function">Precision</span> precision = <span class="number">1</span>;
    
    <span class="comment">// 小数位数限制 (0-20)</span>
    <span class="keyword">int32</span> decimal_places = <span class="number">2</span>;
    
    <span class="comment">// 是否启用科学计数法</span>
    <span class="keyword">bool</span> use_scientific_notation = <span class="number">3</span>;
    
    <span class="comment">// 数值范围限制</span>
    <span class="keyword">double</span> max_value = <span class="number">4</span>;
    <span class="keyword">double</span> min_value = <span class="number">5</span>;
    
    <span class="comment">// 超时设置 (毫秒)</span>
    <span class="keyword">int32</span> timeout_ms = <span class="number">6</span>;
}

<span class="comment">// 请求元数据</span>
<span class="keyword">message</span> <span class="function">RequestMetadata</span> {
    <span class="comment">// 请求ID</span>
    <span class="keyword">string</span> request_id = <span class="number">1</span>;
    
    <span class="comment">// 客户端信息</span>
    <span class="keyword">string</span> client_id = <span class="number">2</span>;
    <span class="keyword">string</span> client_version = <span class="number">3</span>;
    
    <span class="comment">// 时间戳</span>
    google.protobuf.Timestamp request_time = <span class="number">4</span>;
    
    <span class="comment">// 优先级 (1-10, 10最高)</span>
    <span class="keyword">int32</span> priority = <span class="number">5</span>;
}

<span class="comment">// 计算响应</span>
<span class="keyword">message</span> <span class="function">CalculationResponse</span> {
    <span class="comment">// 计算结果 - 支持多种格式</span>
    <span class="keyword">oneof</span> result {
        <span class="keyword">double</span> number_result = <span class="number">1</span>;
        <span class="keyword">string</span> decimal_result = <span class="number">2</span>;  <span class="comment">// 高精度结果</span>
        <span class="keyword">string</span> scientific_result = <span class="number">3</span>; <span class="comment">// 科学计数法</span>
    }
    
    <span class="comment">// 操作状态</span>
    <span class="keyword">bool</span> success = <span class="number">4</span>;
    
    <span class="comment">// 错误信息</span>
    <span class="function">ErrorInfo</span> error = <span class="number">5</span>;
    
    <span class="comment">// 计算统计</span>
    <span class="function">CalculationStats</span> stats = <span class="number">6</span>;
    
    <span class="comment">// 响应元数据</span>
    <span class="function">ResponseMetadata</span> metadata = <span class="number">7</span>;
}

<span class="comment">// 错误信息</span>
<span class="keyword">message</span> <span class="function">ErrorInfo</span> {
    <span class="function">ErrorCode</span> code = <span class="number">1</span>;
    <span class="keyword">string</span> message = <span class="number">2</span>;
    <span class="keyword">string</span> details = <span class="number">3</span>;
    
    <span class="comment">// 错误发生的上下文</span>
    <span class="keyword">string</span> operation_context = <span class="number">4</span>;
    <span class="keyword">repeated string</span> suggestions = <span class="number">5</span>;  <span class="comment">// 修复建议</span>
}

<span class="comment">// 计算统计</span>
<span class="keyword">message</span> <span class="function">CalculationStats</span> {
    <span class="comment">// 执行时间 (微秒)</span>
    <span class="keyword">int64</span> execution_time_us = <span class="number">1</span>;
    
    <span class="comment">// 内存使用 (字节)</span>
    <span class="keyword">int64</span> memory_used_bytes = <span class="number">2</span>;
    
    <span class="comment">// 精度损失标记</span>
    <span class="keyword">bool</span> precision_lost = <span class="number">3</span>;
    
    <span class="comment">// 中间步骤数</span>
    <span class="keyword">int32</span> intermediate_steps = <span class="number">4</span>;
}

<span class="comment">// 响应元数据</span>
<span class="keyword">message</span> <span class="function">ResponseMetadata</span> {
    <span class="keyword">string</span> request_id = <span class="number">1</span>;
    <span class="keyword">string</span> server_id = <span class="number">2</span>;
    <span class="keyword">string</span> server_version = <span class="number">3</span>;
    google.protobuf.Timestamp response_time = <span class="number">4</span>;
}

<span class="comment">// ============== 批量和流式消息 ==============</span>

<span class="comment">// 批量计算请求</span>
<span class="keyword">message</span> <span class="function">BatchCalculationRequest</span> {
    <span class="keyword">repeated</span> <span class="function">CalculationRequest</span> requests = <span class="number">1</span>;
    
    <span class="comment">// 批量配置</span>
    <span class="keyword">bool</span> fail_fast = <span class="number">2</span>;  <span class="comment">// 遇到错误是否立即停止</span>
    <span class="keyword">bool</span> parallel_execution = <span class="number">3</span>;  <span class="comment">// 是否并行执行</span>
    <span class="keyword">int32</span> max_concurrent = <span class="number">4</span>;  <span class="comment">// 最大并发数</span>
}

<span class="comment">// 批量计算响应</span>
<span class="keyword">message</span> <span class="function">BatchCalculationResponse</span> {
    <span class="keyword">repeated</span> <span class="function">CalculationResponse</span> responses = <span class="number">1</span>;
    
    <span class="comment">// 批量统计</span>
    <span class="keyword">int32</span> total_requests = <span class="number">2</span>;
    <span class="keyword">int32</span> successful_requests = <span class="number">3</span>;
    <span class="keyword">int32</span> failed_requests = <span class="number">4</span>;
    <span class="keyword">int64</span> total_execution_time_us = <span class="number">5</span>;
}

<span class="comment">// ============== 服务能力查询 ==============</span>

<span class="keyword">message</span> <span class="function">CapabilitiesRequest</span> {
    <span class="comment">// 空请求，用于获取服务器能力</span>
}

<span class="keyword">message</span> <span class="function">CapabilitiesResponse</span> {
    <span class="comment">// 支持的操作类型</span>
    <span class="keyword">repeated</span> <span class="function">OperationType</span> supported_operations = <span class="number">1</span>;
    
    <span class="comment">// 支持的精度类型</span>
    <span class="keyword">repeated</span> <span class="function">Precision</span> supported_precisions = <span class="number">2</span>;
    
    <span class="comment">// 数值限制</span>
    <span class="keyword">double</span> max_number = <span class="number">3</span>;
    <span class="keyword">double</span> min_number = <span class="number">4</span>;
    <span class="keyword">int32</span> max_decimal_places = <span class="number">5</span>;
    
    <span class="comment">// 性能限制</span>
    <span class="keyword">int32</span> max_batch_size = <span class="number">6</span>;
    <span class="keyword">int32</span> max_concurrent_streams = <span class="number">7</span>;
    <span class="keyword">int32</span> default_timeout_ms = <span class="number">8</span>;
    
    <span class="comment">// 服务器信息</span>
    <span class="keyword">string</span> server_version = <span class="number">9</span>;
    <span class="keyword">string</span> protocol_version = <span class="number">10</span>;
}

<span class="comment">// ============== 表达式验证 ==============</span>

<span class="keyword">message</span> <span class="function">ValidationRequest</span> {
    <span class="function">CalculationRequest</span> request = <span class="number">1</span>;
    
    <span class="comment">// 验证级别</span>
    <span class="keyword">enum</span> <span class="function">ValidationLevel</span> {
        BASIC = <span class="number">0</span>;      <span class="comment">// 基本语法检查</span>
        STRICT = <span class="number">1</span>;     <span class="comment">// 严格类型检查</span>
        COMPLETE = <span class="number">2</span>;   <span class="comment">// 完整验证包括范围检查</span>
    }
    
    <span class="function">ValidationLevel</span> level = <span class="number">2</span>;
}

<span class="keyword">message</span> <span class="function">ValidationResponse</span> {
    <span class="keyword">bool</span> is_valid = <span class="number">1</span>;
    <span class="keyword">repeated string</span> errors = <span class="number">2</span>;
    <span class="keyword">repeated string</span> warnings = <span class="number">3</span>;
    <span class="keyword">repeated string</span> suggestions = <span class="number">4</span>;
    
    <span class="comment">// 预估执行时间</span>
    <span class="keyword">int64</span> estimated_execution_time_us = <span class="number">5</span>;
    
    <span class="comment">// 结果类型预测</span>
    <span class="keyword">string</span> expected_result_type = <span class="number">6</span>;
}</code></pre>
            </div>
        </div>

        <div class="command-section">
            <h3>🔧 生成Python代码命令</h3>
            <pre><code># 安装依赖
pip install grpcio grpcio-tools

# 生成Python gRPC代码
python -m grpc_tools.protoc --proto_path=. --python_out=. --grpc_python_out=. calculator.proto</code></pre>
        </div>

        <div class="step">步骤 2: 实现强类型约束的gRPC服务端</div>

        <div class="file-section">
            <div class="file-header">
                <span class="file-icon">🐍</span>
                calculator_server_enhanced.py - 强类型约束版本
            </div>
            <div class="code-content">
                <pre><code><span class="keyword">import</span> grpc
<span class="keyword">from</span> concurrent <span class="keyword">import</span> futures
<span class="keyword">import</span> time
<span class="keyword">import</span> logging
<span class="keyword">import</span> math
<span class="keyword">import</span> decimal
<span class="keyword">import</span> uuid
<span class="keyword">from</span> datetime <span class="keyword">import</span> datetime
<span class="keyword">from</span> typing <span class="keyword">import</span> Union, Optional, Tuple
<span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass

<span class="comment"># 导入生成的gRPC代码</span>
<span class="keyword">import</span> calculator_enhanced_pb2 <span class="keyword">as</span> pb2
<span class="keyword">import</span> calculator_enhanced_pb2_grpc <span class="keyword">as</span> pb2_grpc
<span class="keyword">from</span> google.protobuf <span class="keyword">import</span> timestamp_pb2

<span class="comment"># 配置日志</span>
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

<span class="comment"># ============== 类型约束和验证类 ==============</span>

<span class="keyword">@dataclass</span>
<span class="keyword">class</span> <span class="function">NumericLimits</span>:
    <span class="string">"""数值限制配置"""</span>
    MAX_VALUE: <span class="keyword">float</span> = <span class="number">1e15</span>
    MIN_VALUE: <span class="keyword">float</span> = <span class="number">-1e15</span>
    MAX_DECIMAL_PLACES: <span class="keyword">int</span> = <span class="number">20</span>
    PRECISION_TOLERANCE: <span class="keyword">float</span> = <span class="number">1e-15</span>

<span class="keyword">class</span> <span class="function">TypeValidator</span>:
    <span class="string">"""类型和值验证器"""</span>
    
    <span class="keyword">@staticmethod</span>
    <span class="keyword">def</span> <span class="function">validate_operation_type</span>(operation: pb2.OperationType) -> Tuple[<span class="keyword">bool</span>, <span class="keyword">str</span>]:
        <span class="string">"""验证操作类型"""</span>
        <span class="keyword">if</span> operation == pb2.OPERATION_UNSPECIFIED:
            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="string">"操作类型未指定"</span>
        
        valid_operations = [
            pb2.OPERATION_ADD, pb2.OPERATION_SUBTRACT, 
            pb2.OPERATION_MULTIPLY, pb2.OPERATION_DIVIDE,
            pb2.OPERATION_POWER, pb2.OPERATION_SQRT, pb2.OPERATION_MODULO
        ]
        
        <span class="keyword">if</span> operation <span class="keyword">not</span> <span class="keyword">in</span> valid_operations:
            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="string">f"不支持的操作类型: {operation}"</span>
        
        <span class="keyword">return</span> <span class="keyword">True</span>, <span class="string">""</span>
    
    <span class="keyword">@staticmethod</span>
    <span class="keyword">def</span> <span class="function">validate_numeric_value</span>(value: <span class="keyword">float</span>, context: <span class="keyword">str</span> = <span class="string">""</span>) -> Tuple[<span class="keyword">bool</span>, <span class="keyword">str</span>]:
        <span class="string">"""验证数值范围"""</span>
        <span class="keyword">if</span> math.isnan(value):
            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="string">f"{context}: 值不能为NaN"</span>
        
        <span class="keyword">if</span> math.isinf(value):
            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="string">f"{context}: 值不能为无穷大"</span>
        
        <span class="keyword">if</span> value > NumericLimits.MAX_VALUE:
            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="string">f"{context}: 值超出最大限制 {NumericLimits.MAX_VALUE}"</span>
        
        <span class="keyword">if</span> value < NumericLimits.MIN_VALUE:
            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="string">f"{context}: 值低于最小限制 {NumericLimits.MIN_VALUE}"</span>
        
        <span class="keyword">return</span> <span class="keyword">True</span>, <span class="string">""</span>
    
    <span class="keyword">@staticmethod</span>
    <span class="keyword">def</span> <span class="function">validate_precision_config</span>(config: pb2.CalculationConfig) -> Tuple[<span class="keyword">bool</span>, <span class="keyword">str</span>]:
        <span class="string">"""验证精度配置"""</span>
        <span class="keyword">if</span> config.decimal_places < <span class="number">0</span> <span class="keyword">or</span> config.decimal_places > NumericLimits.MAX_DECIMAL_PLACES:
            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="string">f"小数位数必须在 0-{NumericLimits.MAX_DECIMAL_PLACES} 之间"</span>
        
        <span class="keyword">if</span> config.timeout_ms <= <span class="number">0</span>:
            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="string">"超时时间必须大于0"</span>
        
        <span class="keyword">return</span> <span class="keyword">True</span>, <span class="string">""</span>

<span class="keyword">class</span> <span class="function">PrecisionCalculator</span>:
    <span class="string">"""高精度计算器"""</span>
    
    <span class="keyword">@staticmethod</span>
    <span class="keyword">def</span> <span class="function">get_numeric_value</span>(request: pb2.CalculationRequest) -> Tuple[<span class="keyword">float</span>, <span class="keyword">float</span>]:
        <span class="string">"""从请求中提取数值，支持不同精度类型"""</span>
        <span class="comment"># 提取操作数A</span>
        <span class="keyword">if</span> request.HasField(<span class="string">"number_a"</span>):
            a = request.number_a
        <span class="keyword">elif</span> request.HasField(<span class="string">"decimal_a"</span>):
            a = <span class="keyword">float</span>(decimal.Decimal(request.decimal_a))
        <span class="keyword">else</span>:
            <span class="keyword">raise</span> ValueError(<span class="string">"操作数A未指定"</span>)
        
        <span class="comment"># 提取操作数B (某些操作不需要)</span>
        <span class="keyword">if</span> request.operation == pb2.OPERATION_SQRT:
            b = <span class="number">0</span>  <span class="comment"># 开方操作不需要第二个操作数</span>
        <span class="keyword">elif</span> request.HasField(<span class="string">"number_b"</span>):
            b = request.number_b
        <span class="keyword">elif</span> request.HasField(<span class="string">"decimal_b"</span>):
            b = <span class="keyword">float</span>(decimal.Decimal(request.decimal_b))
        <span class="keyword">else</span>:
            <span class="keyword">raise</span> ValueError(<span class="string">"操作数B未指定"</span>)
        
        <span class="keyword">return</span> a, b
    
    <span class="keyword">@staticmethod</span>
    <span class="keyword">def</span> <span class="function">format_result</span>(value: <span class="keyword">float</span>, config: pb2.CalculationConfig) -> Tuple[<span class="keyword">str</span>, <span class="keyword">str</span>, <span class="keyword">str</span>]:
        <span class="string">"""根据配置格式化结果"""</span>
        <span class="comment"># 标准数值</span>
        number_result = value
        
        <span class="comment"># 高精度十进制</span>
        decimal_result = <span class="keyword">str</span>(decimal.Decimal(<span class="keyword">str</span>(value)).quantize(
            decimal.Decimal(<span class="string">'0.'</span> + <span class="string">'0'</span> * config.decimal_places),
            rounding=decimal.ROUND_HALF_UP
        ))
        
        <span class="comment"># 科学计数法</span>
        <span class="keyword">if</span> config.use_scientific_notation <span class="keyword">or</span> <span class="keyword">abs</span>(value) >= <span class="number">1e6</span> <span class="keyword">or</span> (<span class="keyword">abs</span>(value) < <span class="number">1e-3</span> <span class="keyword">and</span> value != <span class="number">0</span>):
            scientific_result = <span class="string">f"{value:.{config.decimal_places}e}"</span>
        <span class="keyword">else</span>:
            scientific_result = decimal_result
        
        <span class="keyword">return</span> <span class="keyword">str</span>(number_result), decimal_result, scientific_result

<span class="comment"># ============== 强类型约束的服务实现 ==============</span>

<span class="keyword">class</span> <span class="function">EnhancedCalculatorServicer</span>(pb2_grpc.CalculatorV2Servicer):
    <span class="string">"""增强型计算器服务 - 强类型约束版本"""</span>
    
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>):
        <span class="keyword">self</span>.server_id = <span class="keyword">str</span>(uuid.uuid4())[:8]
        <span class="keyword">self</span>.server_version = <span class="string">"v2.0.0"</span>
        <span class="keyword">self</span>.start_time = datetime.now()
        logger.info(<span class="string">f"Enhanced Calculator Server {<span class="keyword">self</span>.server_id} initialized"</span>)
    
    <span class="keyword">def</span> <span class="function">_create_error_response</span>(<span class="keyword">self</span>, error_code: pb2.ErrorCode, message: <span class="keyword">str</span>, 
                           details: <span class="keyword">str</span> = <span class="string">""</span>, suggestions: list = <span class="keyword">None</span>) -> pb2.CalculationResponse:
        <span class="string">"""创建错误响应"""</span>
        error_info = pb2.ErrorInfo(
            code=error_code,
            message=message,
            details=details,
            suggestions=suggestions <span class="keyword">or</span> []
        )
        
        <span class="keyword">return</span> pb2.CalculationResponse(
            success=<span class="keyword">False</span>,
            error=error_info,
            metadata=<span class="keyword">self</span>._create_response_metadata()
        )
    
    <span class="keyword">def</span> <span class="function">_create_response_metadata</span>(<span class="keyword">self</span>) -> pb2.ResponseMetadata:
        <span class="string">"""创建响应元数据"""</span>
        now = timestamp_pb2.Timestamp()
        now.GetCurrentTime()
        
        <span class="keyword">return</span> pb2.ResponseMetadata(
            server_id=<span class="keyword">self</span>.server_id,
            server_version=<span class="keyword">self</span>.server_version,
            response_time=now
        )
    
    <span class="keyword">def</span> <span class="function">_validate_request</span>(<span class="keyword">self</span>, request: pb2.CalculationRequest) -> Tuple[<span class="keyword">bool</span>, pb2.CalculationResponse]:
        <span class="string">"""全面验证请求 - 展示强类型约束"""</span>
        
        <span class="comment"># 1. 验证操作类型 (枚举约束)</span>
        is_valid, error_msg = TypeValidator.validate_operation_type(request.operation)
        <span class="keyword">if</span> <span class="keyword">not</span> is_valid:
            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="keyword">self</span>._create_error_response(
                pb2.ERROR_INVALID_OPERATION, 
                error_msg,
                suggestions=[<span class="string">"请使用有效的操作类型：ADD, SUBTRACT, MULTIPLY, DIVIDE, POWER, SQRT, MODULO"</span>]
            )
        
        <span class="comment"># 2. 提取和验证数值 (oneof约束确保类型安全)</span>
        <span class="keyword">try</span>:
            a, b = PrecisionCalculator.get_numeric_value(request)
        <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:
            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="keyword">self</span>._create_error_response(
                pb2.ERROR_INVALID_OPERATION,
                <span class="keyword">str</span>(e),
                suggestions=[<span class="string">"请确保操作数已正确设置"</span>]
            )
        
        <span class="comment"># 3. 验证数值范围</span>
        is_valid, error_msg = TypeValidator.validate_numeric_value(a, <span class="string">"操作数A"</span>)
        <span class="keyword">if</span> <span class="keyword">not</span> is_valid:
            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="keyword">self</span>._create_error_response(pb2.ERROR_NUMBER_TOO_LARGE, error_msg)
        
        <span class="keyword">if</span> request.operation != pb2.OPERATION_SQRT:
            is_valid, error_msg = TypeValidator.validate_numeric_value(b, <span class="string">"操作数B"</span>)
            <span class="keyword">if</span> <span class="keyword">not</span> is_valid:
                <span class="keyword">return</span> <span class="keyword">False</span>, <span class="keyword">self</span>._create_error_response(pb2.ERROR_NUMBER_TOO_LARGE, error_msg)
        
        <span class="comment"># 4. 验证特定操作的约束</span>
        <span class="keyword">if</span> request.operation == pb2.OPERATION_DIVIDE <span class="keyword">and</span> b == <span class="number">0</span>:
            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="keyword">self</span>._create_error_response(
                pb2.ERROR_DIVISION_BY_ZERO,
                <span class="string">"除数不能为零"</span>,
                suggestions=[<span class="string">"请使用非零的除数"</span>]
            )
        
        <span class="keyword">if</span> request.operation == pb2.OPERATION_SQRT <span class="keyword">and</span> a < <span class="number">0</span>:
            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="keyword">self</span>._create_error_response(
                pb2.ERROR_NEGATIVE_SQRT,
                <span class="string">"不能计算负数的平方根"</span>,
                suggestions=[<span class="string">"请使用非负数"</span>]
            )
        
        <span class="comment"># 5. 验证精度配置</span>
        <span class="keyword">if</span> request.config:
            is_valid, error_msg = TypeValidator.validate_precision_config(request.config)
            <span class="keyword">if</span> <span class="keyword">not</span> is_valid:
                <span class="keyword">return</span> <span class="keyword">False</span>, <span class="keyword">self</span>._create_error_response(pb2.ERROR_INVALID_OPERATION, error_msg)
        
        <span class="keyword">return</span> <span class="keyword">True</span>, <span class="keyword">None</span>
    
    <span class="keyword">def</span> <span class="function">Calculate</span>(<span class="keyword">self</span>, request: pb2.CalculationRequest, context) -> pb2.CalculationResponse:
        <span class="string">"""主要计算方法 - 强类型约束实现"""</span>
        start_time = time.perf_counter()
        
        <span class="comment"># 验证请求</span>
        is_valid, error_response = <span class="keyword">self</span>._validate_request(request)
        <span class="keyword">if</span> <span class="keyword">not</span> is_valid:
            <span class="keyword">return</span> error_response
        
        <span class="keyword">try</span>:
            <span class="comment"># 提取数值</span>
            a, b = PrecisionCalculator.get_numeric_value(request)
            
            <span class="comment"># 执行计算 - 使用枚举确保类型安全</span>
            <span class="keyword">if</span> request.operation == pb2.OPERATION_ADD:
                result = a + b
                operation_str = <span class="string">f"{a} + {b}"</span>
            <span class="keyword">elif</span> request.operation == pb2.OPERATION_SUBTRACT:
                result = a - b
                operation_str = <span class="string">f"{a} - {b}"</span>
            <span class="keyword">elif</span> request.operation == pb2.OPERATION_MULTIPLY:
                result = a * b
                operation_str = <span class="string">f"{a} * {b}"</span>
            <span class="keyword">elif</span> request.operation == pb2.OPERATION_DIVIDE:
                result = a / b
                operation_str = <span class="string">f"{a} / {b}"</span>
            <span class="keyword">elif</span> request.operation == pb2.OPERATION_POWER:
                result = a ** b
                operation_str = <span class="string">f"{a} ^ {b}"</span>
            <span class="keyword">elif</span> request.operation == pb2.OPERATION_SQRT:
                result = math.sqrt(a)
                operation_str = <span class="string">f"√{a}"</span>
            <span class="keyword">elif</span> request.operation == pb2.OPERATION_MODULO:
                result = a % b
                operation_str = <span class="string">f"{a} % {b}"</span>
            <span class="keyword">else</span>:
                <span class="keyword">return</span> <span class="keyword">self</span>._create_error_response(
                    pb2.ERROR_INVALID_OPERATION,
                    <span class="string">f"未实现的操作: {request.operation}"</span>
                )
            
            <span class="comment"># 检查结果溢出</span>
            <span class="keyword">if</span> math.isinf(result):
                <span class="keyword">return</span> <span class="keyword">self</span>._create_error_response(
                    pb2.ERROR_OVERFLOW,
                    <span class="string">"计算结果溢出"</span>,
                    details=<span class="string">f"操作: {operation_str}"</span>
                )
            
            <span class="comment"># 使用默认配置如果未提供</span>
            config = request.config <span class="keyword">if</span> request.config <span class="keyword">else</span> pb2.CalculationConfig(
                precision=pb2.PRECISION_STANDARD,
                decimal_places=<span class="number">6</span>,
                use_scientific_notation=<span class="keyword">False</span>
            )
            
            <span class="comment"># 格式化结果</span>
            number_result, decimal_result, scientific_result = PrecisionCalculator.format_result(result, config)
            
            execution_time = <span class="keyword">int</span>((time.perf_counter() - start_time) * <span class="number">1_000_000</span>)  <span class="comment"># 微秒</span>
            
            <span class="comment"># 构建成功响应 - 使用强类型结构</span>
            response = pb2.CalculationResponse(
                number_result=result,
                success=<span class="keyword">True</span>,
                stats=pb2.CalculationStats(
                    execution_time_us=execution_time,
                    memory_used_bytes=<span class="number">64</span>,  <span class="comment"># 估算</span>
                    precision_lost=<span class="keyword">abs</span>(result - <span class="keyword">float</span>(decimal_result)) > NumericLimits.PRECISION_TOLERANCE,
                    intermediate_steps=<span class="number">1</span>
                ),
                metadata=<span class="keyword">self</span>._create_response_metadata()
            )
            
            <span class="comment"># 根据精度类型设置相应的结果字段</span>
            <span class="keyword">if</span> config.precision == pb2.PRECISION_HIGH:
                response.decimal_result = decimal_result
            <span class="keyword">elif</span> config.precision == pb2.PRECISION_SCIENTIFIC:
                response.scientific_result = scientific_result
            
            logger.info(<span class="string">f"计算完成: {operation_str} = {result} (耗时: {execution_time}μs)"</span>)
            <span class="keyword">return</span> response
            
        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
            logger.error(<span class="string">f"计算错误: {e}"</span>)
            <span class="keyword">return</span> <span class="keyword">self</span>._create_error_response(
                pb2.ERROR_INVALID_OPERATION,
                <span class="string">f"计算失败: {<span class="keyword">str</span>(e)}"</span>
            )
    
    <span class="keyword">def</span> <span class="function">GetCapabilities</span>(<span class="keyword">self</span>, request: pb2.CapabilitiesRequest, context) -> pb2.CapabilitiesResponse:
        <span class="string">"""获取服务器能力 - 展示类型约束信息"""</span>
        <span class="keyword">return</span> pb2.CapabilitiesResponse(
            supported_operations=[
                pb2.OPERATION_ADD, pb2.OPERATION_SUBTRACT,
                pb2.OPERATION_MULTIPLY, pb2.OPERATION_DIVIDE,
                pb2.OPERATION_POWER, pb2.OPERATION_SQRT, pb2.OPERATION_MODULO
            ],
            supported_precisions=[
                pb2.PRECISION_STANDARD, pb2.PRECISION_HIGH, pb2.PRECISION_SCIENTIFIC
            ],
            max_number=NumericLimits.MAX_VALUE,
            min_number=NumericLimits.MIN_VALUE,
            max_decimal_places=NumericLimits.MAX_DECIMAL_PLACES,
            max_batch_size=<span class="number">1000</span>,
            max_concurrent_streams=<span class="number">100</span>,
            default_timeout_ms=<span class="number">30000</span>,
            server_version=<span class="keyword">self</span>.server_version,
            protocol_version=<span class="string">"v2.0"</span>
        )
    
    <span class="keyword">def</span> <span class="function">ValidateExpression</span>(<span class="keyword">self</span>, request: pb2.ValidationRequest, context) -> pb2.ValidationResponse:
        <span class="string">"""验证表达式 - 展示预检查的类型约束"""</span>
        errors = []
        warnings = []
        suggestions = []
        
        <span class="comment"># 执行验证但不计算</span>
        is_valid, error_response = <span class="keyword">self</span>._validate_request(request.request)
        
        <span class="keyword">if</span> <span class="keyword">not</span> is_valid:
            errors.append(error_response.error.message)
            suggestions.extend(error_response.error.suggestions)
        
        <span class="comment"># 添加警告和建议</span>
        <span class="keyword">try</span>:
            a, b = PrecisionCalculator.get_numeric_value(request.request)
            
            <span class="keyword">if</span> <span class="keyword">abs</span>(a) > <span class="number">1e10</span> <span class="keyword">or</span> <span class="keyword">abs</span>(b) > <span class="number">1e10</span>:
                warnings.append(<span class="string">"使用大数值可能影响精度"</span>)
                suggestions.append(<span class="string">"考虑使用高精度模式"</span>)
            
            <span class="comment"># 预估执行时间</span>
            estimated_time = <span class="number">100</span>  <span class="comment"># 基础时间微秒</span>
            <span class="keyword">if</span> request.request.operation == pb2.OPERATION_POWER:
                estimated_time *= <span class="number">5</span>  <span class="comment"># 幂运算更耗时</span>
            
        <span class="keyword">except</span> Exception:
            estimated_time = <span class="number">0</span>
        
        <span class="keyword">return</span> pb2.ValidationResponse(
            is_valid=<span class="keyword">len</span>(errors) == <span class="number">0</span>,
            errors=errors,
            warnings=warnings,
            suggestions=suggestions,
            estimated_execution_time_us=estimated_time,
            expected_result_type=<span class="string">"number"</span>
        )

<span class="keyword">def</span> <span class="function">serve</span>():
    <span class="string">"""启动增强型gRPC服务器"""</span>
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="number">10</span>))
    
    <span class="comment"># 添加增强型服务</span>
    pb2_grpc.add_CalculatorV2Servicer_to_server(
        EnhancedCalculatorServicer(), server
    )
    
    listen_addr = <span class="string">'[::]:50052'</span>  <span class="comment"># 使用不同端口</span>
    server.add_insecure_port(listen_addr)
    
    server.start()
    logger.info(<span class="string">f"Enhanced Calculator gRPC server (强类型约束版本) started on {listen_addr}"</span>)
    
    <span class="keyword">try</span>:
        server.wait_for_termination()
    <span class="keyword">except</span> KeyboardInterrupt:
        logger.info(<span class="string">"Shutting down enhanced server..."</span>)
        server.stop(<span class="number">0</span>)

<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:
    serve()
</code></pre>
            </div>
        </div>

        <div class="step">步骤 3: 实现强类型约束的gRPC客户端</div>

        <div class="file-section">
            <div class="file-header">
                <span class="file-icon">🐍</span>
                calculator_client_enhanced.py - 强类型约束版本
            </div>
            <div class="code-content">
                <pre><code><span class="keyword">import</span> grpc
<span class="keyword">import</span> time
<span class="keyword">import</span> logging
<span class="keyword">import</span> uuid
<span class="keyword">from</span> datetime <span class="keyword">import</span> datetime
<span class="keyword">from</span> typing <span class="keyword">import</span> Optional, List, Union
<span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass
<span class="keyword">from</span> enum <span class="keyword">import</span> Enum

<span class="comment"># 导入生成的gRPC代码</span>
<span class="keyword">import</span> calculator_enhanced_pb2 <span class="keyword">as</span> pb2
<span class="keyword">import</span> calculator_enhanced_pb2_grpc <span class="keyword">as</span> pb2_grpc
<span class="keyword">from</span> google.protobuf <span class="keyword">import</span> timestamp_pb2

<span class="comment"># 配置日志</span>
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

<span class="comment"># ============== 客户端类型安全包装器 ==============</span>

<span class="keyword">class</span> <span class="function">Operation</span>(Enum):
    <span class="string">"""操作类型枚举 - 客户端类型安全"""</span>
    ADD = pb2.OPERATION_ADD
    SUBTRACT = pb2.OPERATION_SUBTRACT
    MULTIPLY = pb2.OPERATION_MULTIPLY
    DIVIDE = pb2.OPERATION_DIVIDE
    POWER = pb2.OPERATION_POWER
    SQRT = pb2.OPERATION_SQRT
    MODULO = pb2.OPERATION_MODULO

<span class="keyword">class</span> <span class="function">PrecisionType</span>(Enum):
    <span class="string">"""精度类型枚举"""</span>
    STANDARD = pb2.PRECISION_STANDARD
    HIGH = pb2.PRECISION_HIGH
    SCIENTIFIC = pb2.PRECISION_SCIENTIFIC

<span class="keyword">@dataclass</span>
<span class="keyword">class</span> <span class="function">CalculationConfig</span>:
    <span class="string">"""计算配置 - 类型安全的数据类"""</span>
    precision: PrecisionType = PrecisionType.STANDARD
    decimal_places: <span class="keyword">int</span> = <span class="number">6</span>
    use_scientific_notation: <span class="keyword">bool</span> = <span class="keyword">False</span>
    max_value: <span class="keyword">float</span> = <span class="number">1e15</span>
    min_value: <span class="keyword">float</span> = <span class="number">-1e15</span>
    timeout_ms: <span class="keyword">int</span> = <span class="number">30000</span>
    
    <span class="keyword">def</span> <span class="function">to_proto</span>(<span class="keyword">self</span>) -> pb2.CalculationConfig:
        <span class="string">"""转换为protobuf消息"""</span>
        <span class="keyword">return</span> pb2.CalculationConfig(
            precision=<span class="keyword">self</span>.precision.value,
            decimal_places=<span class="keyword">self</span>.decimal_places,
            use_scientific_notation=<span class="keyword">self</span>.use_scientific_notation,
            max_value=<span class="keyword">self</span>.max_value,
            min_value=<span class="keyword">self</span>.min_value,
            timeout_ms=<span class="keyword">self</span>.timeout_ms
        )

<span class="keyword">@dataclass</span>
<span class="keyword">class</span> <span class="function">CalculationResult</span>:
    <span class="string">"""计算结果 - 类型安全的结果类"""</span>
    success: <span class="keyword">bool</span>
    value: Optional[<span class="keyword">float</span>] = <span class="keyword">None</span>
    decimal_value: Optional[<span class="keyword">str</span>] = <span class="keyword">None</span>
    scientific_value: Optional[<span class="keyword">str</span>] = <span class="keyword">None</span>
    error_code: Optional[pb2.ErrorCode] = <span class="keyword">None</span>
    error_message: Optional[<span class="keyword">str</span>] = <span class="keyword">None</span>
    suggestions: List[<span class="keyword">str</span>] = <span class="keyword">None</span>
    execution_time_us: <span class="keyword">int</span> = <span class="number">0</span>
    precision_lost: <span class="keyword">bool</span> = <span class="keyword">False</span>
    
    <span class="keyword">def</span> <span class="function">__post_init__</span>(<span class="keyword">self</span>):
        <span class="keyword">if</span> <span class="keyword">self</span>.suggestions <span class="keyword">is</span> <span class="keyword">None</span>:
            <span class="keyword">self</span>.suggestions = []

<span class="keyword">class</span> <span class="function">InputValidator</span>:
    <span class="string">"""客户端输入验证器 - 早期类型检查"""</span>
    
    <span class="keyword">@staticmethod</span>
    <span class="keyword">def</span> <span class="function">validate_number</span>(value: Union[<span class="keyword">int</span>, <span class="keyword">float</span>, <span class="keyword">str</span>], name: <span class="keyword">str</span>) -> <span class="keyword">float</span>:
        <span class="string">"""验证并转换数字"""</span>
        <span class="keyword">try</span>:
            num = <span class="keyword">float</span>(value)
            <span class="keyword">if</span> <span class="keyword">not</span> (-<span class="number">1e15</span> <= num <= <span class="number">1e15</span>):
                <span class="keyword">raise</span> ValueError(<span class="string">f"{name} 超出允许范围 (-1e15 到 1e15)"</span>)
            <span class="keyword">return</span> num
        <span class="keyword">except</span> (ValueError, TypeError) <span class="keyword">as</span> e:
            <span class="keyword">raise</span> TypeError(<span class="string">f"{name} 必须是有效的数字: {e}"</span>)
    
    <span class="keyword">@staticmethod</span>
    <span class="keyword">def</span> <span class="function">validate_operation</span>(operation: Union[Operation, <span class="keyword">str</span>]) -> Operation:
        <span class="string">"""验证操作类型"""</span>
        <span class="keyword">if</span> <span class="keyword">isinstance</span>(operation, <span class="keyword">str</span>):
            <span class="keyword">try</span>:
                <span class="keyword">return</span> Operation[operation.upper()]
            <span class="keyword">except</span> KeyError:
                valid_ops = <span class="string">", "</span>.join([op.name <span class="keyword">for</span> op <span class="keyword">in</span> Operation])
                <span class="keyword">raise</span> ValueError(<span class="string">f"无效的操作类型: {operation}. 有效类型: {valid_ops}"</span>)
        
        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">isinstance</span>(operation, Operation):
            <span class="keyword">raise</span> TypeError(<span class="string">"操作类型必须是 Operation 枚举或字符串"</span>)
        
        <span class="keyword">return</span> operation

<span class="comment"># ============== 强类型约束的客户端 ==============</span>

<span class="keyword">class</span> <span class="function">EnhancedCalculatorClient</span>:
    <span class="string">"""增强型计算器客户端 - 强类型约束版本"""</span>
    
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, server_address: <span class="keyword">str</span> = <span class="string">'localhost:50052'</span>):
        <span class="keyword">self</span>.server_address = server_address
        <span class="keyword">self</span>.channel: Optional[grpc.Channel] = <span class="keyword">None</span>
        <span class="keyword">self</span>.stub: Optional[pb2_grpc.CalculatorV2Stub] = <span class="keyword">None</span>
        <span class="keyword">self</span>.client_id = <span class="keyword">str</span>(uuid.uuid4())[:8]
        <span class="keyword">self</span>.client_version = <span class="string">"v2.0.0"</span>
        <span class="keyword">self</span>.server_capabilities: Optional[pb2.CapabilitiesResponse] = <span class="keyword">None</span>
    
    <span class="keyword">def</span> <span class="function">connect</span>(<span class="keyword">self</span>) -> <span class="keyword">bool</span>:
        <span class="string">"""连接到gRPC服务器并获取能力信息"""</span>
        <span class="keyword">try</span>:
            <span class="keyword">self</span>.channel = grpc.insecure_channel(<span class="keyword">self</span>.server_address)
            <span class="keyword">self</span>.stub = pb2_grpc.CalculatorV2Stub(<span class="keyword">self</span>.channel)
            
            <span class="comment"># 获取服务器能力</span>
            <span class="keyword">self</span>.server_capabilities = <span class="keyword">self</span>.stub.GetCapabilities(pb2.CapabilitiesRequest())
            
            logger.info(<span class="string">f"已连接到服务器 {<span class="keyword">self</span>.server_address}"</span>)
            logger.info(<span class="string">f"服务器版本: {<span class="keyword">self</span>.server_capabilities.server_version}"</span>)
            logger.info(<span class="string">f"支持的操作: {[op <span class="keyword">for</span> op <span class="keyword">in</span> <span class="keyword">self</span>.server_capabilities.supported_operations]}"</span>)
            
            <span class="keyword">return</span> <span class="keyword">True</span>
            
        <span class="keyword">except</span> grpc.RpcError <span class="keyword">as</span> e:
            logger.error(<span class="string">f"连接失败: {e.details()}"</span>)
            <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="keyword">def</span> <span class="function">disconnect</span>(<span class="keyword">self</span>):
        <span class="string">"""断开连接"""</span>
        <span class="keyword">if</span> <span class="keyword">self</span>.channel:
            <span class="keyword">self</span>.channel.close()
            logger.info(<span class="string">"已断开服务器连接"</span>)
    
    <span class="keyword">def</span> <span class="function">_create_request_metadata</span>(<span class="keyword">self</span>, priority: <span class="keyword">int</span> = <span class="number">5</span>) -> pb2.RequestMetadata:
        <span class="string">"""创建请求元数据"""</span>
        now = timestamp_pb2.Timestamp()
        now.GetCurrentTime()
        
        <span class="keyword">return</span> pb2.RequestMetadata(
            request_id=<span class="keyword">str</span>(uuid.uuid4()),
            client_id=<span class="keyword">self</span>.client_id,
            client_version=<span class="keyword">self</span>.client_version,
            request_time=now,
            priority=priority
        )
    
    <span class="keyword">def</span> <span class="function">_parse_response</span>(<span class="keyword">self</span>, response: pb2.CalculationResponse) -> CalculationResult:
        <span class="string">"""解析响应为类型安全的结果对象"""</span>
        <span class="keyword">if</span> response.success:
            <span class="comment"># 提取结果值</span>
            value = <span class="keyword">None</span>
            decimal_value = <span class="keyword">None</span>
            scientific_value = <span class="keyword">None</span>
            
            <span class="keyword">if</span> response.HasField(<span class="string">"number_result"</span>):
                value = response.number_result
            <span class="keyword">if</span> response.HasField(<span class="string">"decimal_result"</span>):
                decimal_value = response.decimal_result
            <span class="keyword">if</span> response.HasField(<span class="string">"scientific_result"</span>):
                scientific_value = response.scientific_result
            
            <span class="keyword">return</span> CalculationResult(
                success=<span class="keyword">True</span>,
                value=value,
                decimal_value=decimal_value,
                scientific_value=scientific_value,
                execution_time_us=response.stats.execution_time_us <span class="keyword">if</span> response.stats <span class="keyword">else</span> <span class="number">0</span>,
                precision_lost=response.stats.precision_lost <span class="keyword">if</span> response.stats <span class="keyword">else</span> <span class="keyword">False</span>
            )
        <span class="keyword">else</span>:
            <span class="keyword">return</span> CalculationResult(
                success=<span class="keyword">False</span>,
                error_code=response.error.code,
                error_message=response.error.message,
                suggestions=<span class="keyword">list</span>(response.error.suggestions)
            )
    
    <span class="keyword">def</span> <span class="function">calculate</span>(<span class="keyword">self</span>, 
                a: Union[<span class="keyword">int</span>, <span class="keyword">float</span>, <span class="keyword">str</span>], 
                b: Union[<span class="keyword">int</span>, <span class="keyword">float</span>, <span class="keyword">str</span>], 
                operation: Union[Operation, <span class="keyword">str</span>],
                config: Optional[CalculationConfig] = <span class="keyword">None</span>,
                use_high_precision: <span class="keyword">bool</span> = <span class="keyword">False</span>) -> CalculationResult:
        <span class="string">"""执行计算 - 强类型约束接口"""</span>
        
        <span class="keyword">try</span>:
            <span class="comment"># 客户端类型验证</span>
            validated_a = InputValidator.validate_number(a, <span class="string">"操作数A"</span>)
            validated_operation = InputValidator.validate_operation(operation)
            
            <span class="comment"># 对于开方操作，不需要第二个操作数</span>
            <span class="keyword">if</span> validated_operation == Operation.SQRT:
                validated_b = <span class="number">0</span>  <span class="comment"># 占位符</span>
            <span class="keyword">else</span>:
                validated_b = InputValidator.validate_number(b, <span class="string">"操作数B"</span>)
            
            <span class="comment"># 创建配置</span>
            <span class="keyword">if</span> config <span class="keyword">is</span> <span class="keyword">None</span>:
                config = CalculationConfig()
                <span class="keyword">if</span> use_high_precision:
                    config.precision = PrecisionType.HIGH
                    config.decimal_places = <span class="number">15</span>
            
            <span class="comment"># 构建请求 - 使用oneof确保类型安全</span>
            request = pb2.CalculationRequest(
                operation=validated_operation.value,
                config=config.to_proto(),
                metadata=<span class="keyword">self</span>._create_request_metadata()
            )
            
            <span class="comment"># 根据精度类型设置操作数</span>
            <span class="keyword">if</span> use_high_precision:
                request.decimal_a = <span class="keyword">str</span>(validated_a)
                <span class="keyword">if</span> validated_operation != Operation.SQRT:
                    request.decimal_b = <span class="keyword">str</span>(validated_b)
            <span class="keyword">else</span>:
                request.number_a = validated_a
                <span class="keyword">if</span> validated_operation != Operation.SQRT:
                    request.number_b = validated_b
            
            <span class="comment"># 发送请求</span>
            response = <span class="keyword">self</span>.stub.Calculate(request)
            <span class="keyword">return</span> <span class="keyword">self</span>._parse_response(response)
            
        <span class="keyword">except</span> (TypeError, ValueError) <span class="keyword">as</span> e:
            <span class="comment"># 客户端验证错误</span>
            <span class="keyword">return</span> CalculationResult(
                success=<span class="keyword">False</span>,
                error_message=<span class="string">f"客户端验证失败: {e}"</span>,
                suggestions=[<span class="string">"请检查输入参数的类型和范围"</span>]
            )
        <span class="keyword">except</span> grpc.RpcError <span class="keyword">as</span> e:
            <span class="comment"># gRPC通信错误</span>
            <span class="keyword">return</span> CalculationResult(
                success=<span class="keyword">False</span>,
                error_message=<span class="string">f"通信错误: {e.details()}"</span>
            )
    
    <span class="keyword">def</span> <span class="function">validate_expression</span>(<span class="keyword">self</span>, 
                           a: Union[<span class="keyword">int</span>, <span class="keyword">float</span>, <span class="keyword">str</span>], 
                           b: Union[<span class="keyword">int</span>, <span class="keyword">float</span>, <span class="keyword">str</span>], 
                           operation: Union[Operation, <span class="keyword">str</span>]) -> pb2.ValidationResponse:
        <span class="string">"""验证表达式而不执行计算"""</span>
        <span class="keyword">try</span>:
            validated_a = InputValidator.validate_number(a, <span class="string">"操作数A"</span>)
            validated_b = InputValidator.validate_number(b, <span class="string">"操作数B"</span>) <span class="keyword">if</span> operation != <span class="string">"SQRT"</span> <span class="keyword">else</span> <span class="number">0</span>
            validated_operation = InputValidator.validate_operation(operation)
            
            request = pb2.CalculationRequest(
                number_a=validated_a,
                number_b=validated_b,
                operation=validated_operation.value
            )
            
            validation_request = pb2.ValidationRequest(
                request=request,
                level=pb2.ValidationRequest.COMPLETE
            )
            
            <span class="keyword">return</span> <span class="keyword">self</span>.stub.ValidateExpression(validation_request)
            
        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
            <span class="comment"># 返回客户端验证错误</span>
            <span class="keyword">return</span> pb2.ValidationResponse(
                is_valid=<span class="keyword">False</span>,
                errors=[<span class="string">f"客户端验证失败: {e}"</span>]
            )
    
    <span class="keyword">def</span> <span class="function">get_server_info</span>(<span class="keyword">self</span>) -> Optional[pb2.CapabilitiesResponse]:
        <span class="string">"""获取服务器能力信息"""</span>
        <span class="keyword">return</span> <span class="keyword">self</span>.server_capabilities

<span class="comment"># ============== 类型安全的演示函数 ==============</span>

<span class="keyword">def</span> <span class="function">demo_type_safety</span>():
    <span class="string">"""演示强类型约束的优势"""</span>
    client = EnhancedCalculatorClient()
    
    <span class="keyword">if</span> <span class="keyword">not</span> client.connect():
        <span class="keyword">print</span>(<span class="string">"❌ 无法连接到服务器"</span>)
        <span class="keyword">return</span>
    
    <span class="keyword">print</span>(<span class="string">"=== 强类型约束演示 ==="</span>)
    
    <span class="comment"># 1. 正常计算 - 类型安全</span>
    <span class="keyword">print</span>(<span class="string">"\n🔹 正常计算演示:"</span>)
    result = client.calculate(<span class="number">10.5</span>, <span class="number">3.2</span>, Operation.ADD)
    <span class="keyword">print</span>(<span class="string">f"10.5 + 3.2 = {result.value} (成功: {result.success})"</span>)
    
    <span class="comment"># 2. 枚举类型约束</span>
    <span class="keyword">print</span>(<span class="string">"\n🔹 使用字符串操作类型 (自动转换):"</span>)
    result = client.calculate(<span class="number">8</span>, <span class="number">2</span>, <span class="string">"DIVIDE"</span>)  <span class="comment"># 字符串会被转换为枚举</span>
    <span class="keyword">print</span>(<span class="string">f"8 ÷ 2 = {result.value} (成功: {result.success})"</span>)
    
    <span class="comment"># 3. 高精度计算</span>
    <span class="keyword">print</span>(<span class="string">"\n🔹 高精度计算:"</span>)
    result = client.calculate(<span class="string">"123.456789012345"</span>, <span class="string">"987.654321098765"</span>, 
                            Operation.MULTIPLY, use_high_precision=<span class="keyword">True</span>)
    <span class="keyword">print</span>(<span class="string">f"高精度乘法: {result.decimal_value} (精度损失: {result.precision_lost})"</span>)
    
    <span class="comment"># 4. 单操作数运算 (开方)</span>
    <span class="keyword">print</span>(<span class="string">"\n🔹 开方运算 (单操作数):"</span>)
    result = client.calculate(<span class="number">16</span>, <span class="number">0</span>, Operation.SQRT)  <span class="comment"># b会被忽略</span>
    <span class="keyword">print</span>(<span class="string">f"√16 = {result.value} (成功: {result.success})"</span>)
    
    <span class="comment"># 5. 类型错误处理</span>
    <span class="keyword">print</span>(<span class="string">"\n🔹 类型错误处理:"</span>)
    
    <span class="comment"># 无效操作类型</span>
    result = client.calculate(<span class="number">5</span>, <span class="number">3</span>, <span class="string">"INVALID_OP"</span>)
    <span class="keyword">print</span>(<span class="string">f"无效操作: {result.error_message}"</span>)
    
    <span class="comment"># 无效数值</span>
    result = client.calculate(<span class="string">"abc"</span>, <span class="number">3</span>, Operation.ADD)
    <span class="keyword">print</span>(<span class="string">f"无效数值: {result.error_message}"</span>)
    
    <span class="comment"># 6. 服务端验证</span>
    <span class="keyword">print</span>(<span class="string">"\n🔹 服务端类型验证:"</span>)
    
    <span class="comment"># 除零错误</span>
    result = client.calculate(<span class="number">10</span>, <span class="number">0</span>, Operation.DIVIDE)
    <span class="keyword">print</span>(<span class="string">f"除零错误: {result.error_message}"</span>)
    <span class="keyword">if</span> result.suggestions:
        <span class="keyword">print</span>(<span class="string">f"建议: {', '.join(result.suggestions)}"</span>)
    
    <span class="comment"># 负数开方</span>
    result = client.calculate(<span class="number">-4</span>, <span class="number">0</span>, Operation.SQRT)
    <span class="keyword">print</span>(<span class="string">f"负数开方: {result.error_message}"</span>)
    
    <span class="comment"># 7. 表达式预验证</span>
    <span class="keyword">print</span>(<span class="string">"\n🔹 表达式预验证:"</span>)
    validation = client.validate_expression(<span class="number">100</span>, <span class="number">5</span>, Operation.DIVIDE)
    <span class="keyword">print</span>(<span class="string">f"表达式有效: {validation.is_valid}"</span>)
    <span class="keyword">print</span>(<span class="string">f"预估执行时间: {validation.estimated_execution_time_us}μs"</span>)
    
    <span class="comment"># 8. 服务器能力查询</span>
    <span class="keyword">print</span>(<span class="string">"\n🔹 服务器能力:"</span>)
    capabilities = client.get_server_info()
    <span class="keyword">if</span> capabilities:
        <span class="keyword">print</span>(<span class="string">f"最大数值: {capabilities.max_number}"</span>)
        <span class="keyword">print</span>(<span class="string">f"最大小数位: {capabilities.max_decimal_places}"</span>)
        <span class="keyword">print</span>(<span class="string">f"支持的精度类型: {<span class="keyword">len</span>(capabilities.supported_precisions)}"</span>)
    
    client.disconnect()

<span class="keyword">def</span> <span class="function">interactive_type_safe_demo</span>():
    <span class="string">"""交互式类型安全演示"""</span>
    client = EnhancedCalculatorClient()
    
    <span class="keyword">if</span> <span class="keyword">not</span> client.connect():
        <span class="keyword">print</span>(<span class="string">"❌ 无法连接到服务器"</span>)
        <span class="keyword">return</span>
    
    <span class="keyword">print</span>(<span class="string">"\n=== 类型安全交互式计算器 ==="</span>)
    <span class="keyword">print</span>(<span class="string">"支持的操作: ADD, SUBTRACT, MULTIPLY, DIVIDE, POWER, SQRT, MODULO"</span>)
    <span class="keyword">print</span>(<span class="string">"输入 'quit' 退出, 'info' 查看服务器信息"</span>)
    
    <span class="keyword">while</span> <span class="keyword">True</span>:
        <span class="keyword">try</span>:
            cmd = input(<span class="string">"\n> "</span>).strip()
            
            <span class="keyword">if</span> cmd.lower() == <span class="string">'quit'</span>:
                <span class="keyword">break</span>
            <span class="keyword">elif</span> cmd.lower() == <span class="string">'info'</span>:
                capabilities = client.get_server_info()
                <span class="keyword">if</span> capabilities:
                    <span class="keyword">print</span>(<span class="string">f"服务器版本: {capabilities.server_version}"</span>)
                    <span class="keyword">print</span>(<span class="string">f"协议版本: {capabilities.protocol_version}"</span>)
                    <span class="keyword">print</span>(<span class="string">f"数值范围: {capabilities.min_number} 到 {capabilities.max_number}"</span>)
                <span class="keyword">continue</span>
            
            operation = input(<span class="string">"操作类型: "</span>).strip().upper()
            a = input(<span class="string">"第一个数: "</span>).strip()
            
            <span class="keyword">if</span> operation != <span class="string">'SQRT'</span>:
                b = input(<span class="string">"第二个数: "</span>).strip()
            <span class="keyword">else</span>:
                b = <span class="string">"0"</span>
            
            precision = input(<span class="string">"使用高精度? (y/n): "</span>).strip().lower() == <span class="string">'y'</span>
            
            <span class="comment"># 执行计算</span>
            result = client.calculate(a, b, operation, use_high_precision=precision)
            
            <span class="keyword">if</span> result.success:
                <span class="keyword">if</span> precision <span class="keyword">and</span> result.decimal_value:
                    <span class="keyword">print</span>(<span class="string">f"✅ 结果: {result.decimal_value}"</span>)
                <span class="keyword">else</span>:
                    <span class="keyword">print</span>(<span class="string">f"✅ 结果: {result.value}"</span>)
                <span class="keyword">print</span>(<span class="string">f"   执行时间: {result.execution_time_us}μs"</span>)
                <span class="keyword">if</span> result.precision_lost:
                    <span class="keyword">print</span>(<span class="string">"   ⚠️  检测到精度损失"</span>)
            <span class="keyword">else</span>:
                <span class="keyword">print</span>(<span class="string">f"❌ 错误: {result.error_message}"</span>)
                <span class="keyword">if</span> result.suggestions:
                    <span class="keyword">print</span>(<span class="string">f"   建议: {', '.join(result.suggestions)}"</span>)
                    
        <span class="keyword">except</span> KeyboardInterrupt:
            <span class="keyword">break</span>
        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
            <span class="keyword">print</span>(<span class="string">f"❌ 输入错误: {e}"</span>)
    
    client.disconnect()
    <span class="keyword">print</span>(<span class="string">"👋 再见！"</span>)

<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:
    <span class="keyword">try</span>:
        demo_type_safety()
        interactive_type_safe_demo()
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        <span class="keyword">print</span>(<span class="string">f"演示错误: {e}"</span>)
</code></pre>
            </div>
        </div>

        <div class="step">步骤 4: 创建项目启动脚本</div>

        <div class="file-section">
            <div class="file-header">
                <span class="file-icon">📜</span>
                run_demo.py
            </div>
            <div class="code-content">
                <pre><code><span class="keyword">import</span> subprocess
<span class="keyword">import</span> sys
<span class="keyword">import</span> time
<span class="keyword">import</span> threading
<span class="keyword">import</span> os

<span class="keyword">def</span> <span class="function">generate_proto_code</span>():
    <span class="string">"""生成Protocol Buffer代码"""</span>
    <span class="keyword">print</span>(<span class="string">"🔧 生成gRPC代码..."</span>)
    
    <span class="comment"># 创建proto文件</span>
    proto_content = <span class="string">'''syntax = "proto3";

package calculator;

service Calculator {
    rpc Add(BinaryOperation) returns (Result);
    rpc Subtract(BinaryOperation) returns (Result);
    rpc Multiply(BinaryOperation) returns (Result);
    rpc Divide(BinaryOperation) returns (Result);
    rpc CalculateStream(stream BinaryOperation) returns (stream Result);
}

message BinaryOperation {
    double a = 1;
    double b = 2;
    string operation = 3;
}

message Result {
    double value = 1;
    string message = 2;
    bool success = 3;
}'''</span>
    
    <span class="keyword">with</span> open(<span class="string">'calculator.proto'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:
        f.write(proto_content)
    
    <span class="comment"># 生成Python代码</span>
    <span class="keyword">try</span>:
        subprocess.run([
            sys.executable, <span class="string">'-m'</span>, <span class="string">'grpc_tools.protoc'</span>,
            <span class="string">'--proto_path=.'</span>,
            <span class="string">'--python_out=.'</span>,
            <span class="string">'--grpc_python_out=.'</span>,
            <span class="string">'calculator.proto'</span>
        ], check=<span class="keyword">True</span>)
        <span class="keyword">print</span>(<span class="string">"✅ gRPC代码生成成功！"</span>)
    <span class="keyword">except</span> subprocess.CalledProcessError:
        <span class="keyword">print</span>(<span class="string">"❌ 代码生成失败，请检查grpcio-tools是否安装"</span>)
        <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="keyword">return</span> <span class="keyword">True</span>

<span class="keyword">def</span> <span class="function">check_dependencies</span>():
    <span class="string">"""检查依赖包"""</span>
    <span class="keyword">print</span>(<span class="string">"📦 检查依赖包..."</span>)
    
    required_packages = [<span class="string">'grpcio'</span>, <span class="string">'grpcio-tools'</span>]
    missing_packages = []
    
    <span class="keyword">for</span> package <span class="keyword">in</span> required_packages:
        <span class="keyword">try</span>:
            __import__(package.replace(<span class="string">'-'</span>, <span class="string">'_'</span>))
        <span class="keyword">except</span> ImportError:
            missing_packages.append(package)
    
    <span class="keyword">if</span> missing_packages:
        <span class="keyword">print</span>(<span class="string">f"❌ 缺少依赖包: {', '.join(missing_packages)}"</span>)
        <span class="keyword">print</span>(<span class="string">"请运行: pip install grpcio grpcio-tools"</span>)
        <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="keyword">print</span>(<span class="string">"✅ 所有依赖包已安装"</span>)
    <span class="keyword">return</span> <span class="keyword">True</span>

<span class="keyword">def</span> <span class="function">run_server</span>():
    <span class="string">"""在后台运行服务器"""</span>
    <span class="keyword">import</span> calculator_server
    calculator_server.serve()

<span class="keyword">def</span> <span class="function">main</span>():
    <span class="string">"""主函数"""</span>
    <span class="keyword">print</span>(<span class="string">"🚀 gRPC Calculator Demo 启动中..."</span>)
    
    <span class="comment"># 检查依赖</span>
    <span class="keyword">if</span> <span class="keyword">not</span> check_dependencies():
        <span class="keyword">return</span>
    
    <span class="comment"># 生成代码</span>
    <span class="keyword">if</span> <span class="keyword">not</span> generate_proto_code():
        <span class="keyword">return</span>
    
    <span class="comment"># 启动服务器</span>
    <span class="keyword">print</span>(<span class="string">"🔥 启动gRPC服务器..."</span>)
    server_thread = threading.Thread(target=run_server, daemon=<span class="keyword">True</span>)
    server_thread.start()
    
    <span class="comment"># 等待服务器启动</span>
    time.sleep(<span class="number">2</span>)
    
    <span class="comment"># 运行客户端演示</span>
    <span class="keyword">print</span>(<span class="string">"🎯 启动客户端演示..."</span>)
    <span class="keyword">import</span> calculator_client
    
    <span class="keyword">try</span>:
        calculator_client.demo_basic_operations()
        calculator_client.demo_stream_operations()
        
        <span class="keyword">print</span>(<span class="string">"\n🎮 启动交互式演示..."</span>)
        calculator_client.interactive_demo()
        
    <span class="keyword">except</span> KeyboardInterrupt:
        <span class="keyword">print</span>(<span class="string">"\n👋 演示结束"</span>)

<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:
    main()
</code></pre>
            </div>
        </div>

        <div class="step">步骤 5: 运行强类型约束演示</div>

        <div class="demo-controls">
            <h3>🎮 运行说明</h3>
            <p>这个增强版演示展示了gRPC强大的类型约束能力：</p>
            <ul>
                <li><strong>强类型Protocol Buffer定义</strong> - 枚举、oneof、嵌套消息</li>
                <li><strong>多层验证机制</strong> - 客户端预验证 + 服务端业务验证</li>
                <li><strong>结构化错误处理</strong> - 错误代码、详细信息、修复建议</li>
                <li><strong>高精度计算支持</strong> - 多种数值表示格式</li>
                <li><strong>服务能力查询</strong> - 动态获取服务器支持的功能</li>
                <li><strong>类型安全的客户端包装器</strong> - Python枚举和数据类</li>
            </ul>
            
            <div class="command-section">
                <h3>🔧 运行步骤</h3>
                <pre><code># 1. 安装依赖
pip install grpcio grpcio-tools

# 2. 生成增强版本的proto代码
python -m grpc_tools.protoc \
    --proto_path=. \
    --python_out=. \
    --grpc_python_out=. \
    calculator_enhanced.proto

# 3a. 运行增强版服务器 (端口50052)
python calculator_server_enhanced.py

# 3b. 在另一个终端运行增强版客户端
python calculator_client_enhanced.py

# 或者同时运行基础版本进行对比：
# 终端1: python calculator_server.py      (端口50051)
# 终端2: python calculator_server_enhanced.py (端口50052)
# 终端3: python calculator_client.py       (连接50051)
# 终端4: python calculator_client_enhanced.py (连接50052)</code></pre>
            </div>
        </div>

        <div class="step">🎯 强类型约束演示内容</div>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin: 20px 0;">
            <div class="file-section">
                <div class="file-header">
                    <span class="file-icon">🔒</span>
                    类型安全演示
                </div>
                <div class="code-content">
                    <p><strong>✅ 正确用法：</strong></p>
                    <p>• <code>Operation.ADD</code> - 枚举类型安全</p>
                    <p>• <code>"DIVIDE"</code> - 字符串自动转换</p>
                    <p>• 高精度十进制计算</p>
                    <p>• 单操作数运算(开方)</p>
                    <br>
                    <p><strong>❌ 错误处理：</strong></p>
                    <p>• 无效操作类型检测</p>
                    <p>• 无效数值输入检测</p>
                    <p>• 除零错误防护</p>
                    <p>• 负数开方检测</p>
                </div>
            </div>

            <div class="file-section">
                <div class="file-header">
                    <span class="file-icon">⚡</span>
                    验证机制演示
                </div>
                <div class="code-content">
                    <p><strong>客户端验证：</strong></p>
                    <p>• 输入类型检查</p>
                    <p>• 数值范围验证</p>
                    <p>• 操作类型转换</p>
                    <p>• 早期错误发现</p>
                    <br>
                    <p><strong>服务端验证：</strong></p>
                    <p>• 业务逻辑检查</p>
                    <p>• 数学约束验证</p>
                    <p>• 精度配置检查</p>
                    <p>• 表达式预验证</p>
                </div>
            </div>

            <div class="file-section">
                <div class="file-header">
                    <span class="file-icon">📊</span>
                    元数据和统计
                </div>
                <div class="code-content">
                    <p><strong>请求元数据：</strong></p>
                    <p>• 唯一请求ID</p>
                    <p>• 客户端信息</p>
                    <p>• 时间戳记录</p>
                    <p>• 优先级设置</p>
                    <br>
                    <p><strong>执行统计：</strong></p>
                    <p>• 微秒级执行时间</p>
                    <p>• 内存使用量</p>
                    <p>• 精度损失检测</p>
                    <p>• 服务器能力查询</p>
                </div>
            </div>

            <div class="file-section">
                <div class="file-header">
                    <span class="file-icon">🎮</span>
                    交互体验
                </div>
                <div class="code-content">
                    <p><strong>演示模式：</strong></p>
                    <p>• 类型安全计算展示</p>
                    <p>• 错误处理演示</p>
                    <p>• 高精度计算对比</p>
                    <p>• 服务器能力查询</p>
                    <br>
                    <p><strong>交互模式：</strong></p>
                    <p>• 类型安全输入</p>
                    <p>• 实时验证反馈</p>
                    <p>• 详细错误信息</p>
                    <p>• 修复建议提示</p>
                </div>
            </div>
        </div>

        <div class="step">步骤 8: 部署和最佳实践指南</div>

        <div class="file-section">
            <div class="file-header">
                <span class="file-icon">📋</span>
                best_practices.md - gRPC强类型约束最佳实践
            </div>
            <div class="code-content">
                <pre><code># gRPC强类型约束最佳实践指南

## 🎯 设计原则

### 1. 优先使用强类型定义
```protobuf
// ✅ 推荐：使用枚举类型
enum OperationType {
    OPERATION_UNSPECIFIED = 0;  // 总是包含默认值
    OPERATION_ADD = 1;
    OPERATION_SUBTRACT = 2;
}

// ❌ 避免：使用字符串类型
message BadRequest {
    string operation = 1;  // 容易出错
}
```

### 2. 合理使用oneof字段
```protobuf
// ✅ 推荐：类型安全的多选一
message CalculationRequest {
    oneof operand {
        double number = 1;
        string decimal_string = 2;
        bytes binary_data = 3;
    }
}

// ❌ 避免：多个可选字段
message BadRequest {
    optional double number = 1;
    optional string decimal_string = 2;  // 可能同时设置
}
```

### 3. 版本化管理
```protobuf
// ✅ 推荐：明确的包版本
syntax = "proto3";
package myservice.v2;

// 保持向前兼容
message RequestV2 {
    // 新字段使用新的字段号
    string new_field = 10;
}
```

## 🔧 开发最佳实践

### 1. 多层验证策略
```python
# 客户端预验证
def validate_input(value):
    if not isinstance(value, (int, float)):
        raise TypeError("输入必须是数字")
    if abs(value) > MAX_VALUE:
        raise ValueError("数值超出范围")

# 服务端业务验证  
def validate_business_logic(request):
    if request.operation == DIVIDE and request.b == 0:
        return create_error(ERROR_DIVISION_BY_ZERO)
```

### 2. 结构化错误处理
```python
# ✅ 推荐：结构化错误信息
class ErrorHandler:
    @staticmethod
    def create_error(code, message, suggestions=None):
        return ErrorInfo(
            code=code,
            message=message,
            suggestions=suggestions or [],
            context=get_current_context()
        )

# ❌ 避免：简单字符串错误
def bad_error_handling():
    return "something went wrong"
```

### 3. 性能优化
```python
# ✅ 推荐：连接池和复用
class GrpcClientPool:
    def __init__(self, target, pool_size=10):
        self.channels = [
            grpc.insecure_channel(target) 
            for _ in range(pool_size)
        ]
    
    def get_stub(self):
        return MyServiceStub(random.choice(self.channels))

# ✅ 推荐：批量操作
def batch_calculate(requests):
    return stub.BatchCalculate(
        BatchRequest(requests=requests)
    )
```

## 🚀 生产环境部署

### 1. 安全配置
```python
# TLS配置
credentials = grpc.ssl_channel_credentials()
channel = grpc.secure_channel('server:443', credentials)

# 认证拦截器
def auth_interceptor(continuation, client_call_details, request):
    metadata = client_call_details.metadata or []
    metadata.append(('authorization', f'Bearer {get_token()}'))
    new_details = client_call_details._replace(metadata=metadata)
    return continuation(new_details, request)
```

### 2. 监控和可观测性
```python
# 指标收集
import prometheus_client

REQUEST_COUNT = prometheus_client.Counter(
    'grpc_requests_total',
    'Total gRPC requests',
    ['method', 'status']
)

REQUEST_DURATION = prometheus_client.Histogram(
    'grpc_request_duration_seconds',
    'gRPC request duration'
)

# 链路追踪
def trace_interceptor(continuation, client_call_details, request):
    with tracer.start_span(client_call_details.method) as span:
        span.set_attribute('grpc.method', client_call_details.method)
        return continuation(client_call_details, request)
```

### 3. 配置管理
```python
# 环境配置
@dataclass
class GrpcConfig:
    server_address: str = os.getenv('GRPC_SERVER', 'localhost:50051')
    max_retries: int = int(os.getenv('GRPC_MAX_RETRIES', '3'))
    timeout_seconds: int = int(os.getenv('GRPC_TIMEOUT', '30'))
    
    # TLS设置
    use_tls: bool = os.getenv('GRPC_USE_TLS', 'false').lower() == 'true'
    cert_file: str = os.getenv('GRPC_CERT_FILE', '')
```

## 🧪 测试策略

### 1. 单元测试
```python
class TestCalculatorService(unittest.TestCase):
    def setUp(self):
        self.servicer = CalculatorServicer()
        self.context = create_mock_context()
    
    def test_add_operation(self):
        request = CalculationRequest(a=10, b=5, operation=ADD)
        response = self.servicer.Calculate(request, self.context)
        self.assertEqual(response.result, 15)
```

### 2. 集成测试
```python
class TestIntegration(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.server = start_test_server()
        cls.client = create_test_client()
    
    def test_end_to_end(self):
        result = self.client.calculate(10, 5, 'ADD')
        self.assertTrue(result.success)
```

### 3. 性能测试
```python
def performance_test():
    with ThreadPoolExecutor(max_workers=100) as executor:
        futures = [
            executor.submit(client.calculate, i, i+1, 'ADD')
            for i in range(1000)
        ]
        
        results = [f.result() for f in futures]
        success_rate = sum(1 for r in results if r.success) / len(results)
        assert success_rate > 0.99
```

## 📊 监控指标

### 关键指标
- 请求延迟 (P50, P95, P99)
- 错误率 (按错误类型分类)
- 吞吐量 (QPS)
- 并发连接数
- 内存使用量

### 告警规则
```yaml
# Prometheus告警规则示例
groups:
- name: grpc_alerts
  rules:
  - alert: HighErrorRate
    expr: rate(grpc_requests_failed_total[5m]) > 0.05
    for: 2m
    annotations:
      summary: "gRPC服务错误率过高"
  
  - alert: HighLatency
    expr: histogram_quantile(0.95, grpc_request_duration_seconds) > 1
    for: 5m
    annotations:
      summary: "gRPC服务延迟过高"
```

## 🔄 版本演进策略

### 向前兼容原则
1. **新字段使用新字段号**
2. **不删除现有字段**
3. **枚举值只增不减**
4. **使用optional而非required**

### 迁移策略
```python
# 版本协商
def negotiate_version(client_version):
    if client_version >= "2.0":
        return use_v2_features()
    else:
        return use_v1_compatibility()

# 渐进式迁移
def gradual_migration():
    if feature_flag('use_v2_calculation'):
        return calculate_v2(request)
    else:
        return calculate_v1(request)
```

## 📚 工具和资源

### 开发工具
- **grpcurl**: 命令行测试工具
- **grpc-web**: 浏览器端gRPC支持
- **buf**: Protocol Buffer管理工具
- **grpc-gateway**: REST到gRPC的网关

### 调试技巧
```bash
# 使用grpcurl测试
grpcurl -plaintext -d '{"a":10,"b":5,"operation":"ADD"}' \
  localhost:50051 calculator.Calculator/Calculate

# 启用gRPC调试日志
export GRPC_VERBOSITY=DEBUG
export GRPC_TRACE=all
```

## 💡 常见陷阱和解决方案

### 1. 字段号冲突
```protobuf
// ❌ 问题：重复使用字段号
message BadMessage {
    string name = 1;
    int32 age = 1;  // 字段号冲突！
}

// ✅ 解决：使用唯一字段号
message GoodMessage {
    string name = 1;
    int32 age = 2;
}
```

### 2. 大消息处理
```python
# ✅ 解决：设置消息大小限制
options = [
    ('grpc.max_send_message_length', 100 * 1024 * 1024),
    ('grpc.max_receive_message_length', 100 * 1024 * 1024),
]
channel = grpc.insecure_channel('localhost:50051', options=options)
```

### 3. 连接管理
```python
# ✅ 解决：优雅关闭
class GrpcClient:
    def __enter__(self):
        self.channel = grpc.insecure_channel(self.target)
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.channel.close()
```

通过遵循这些最佳实践，可以构建出健壮、可维护、高性能的gRPC服务。
</code></pre>
            </div>
        </div>

        <div class="command-section">
            <h3>🎯 完整演示总结</h3>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                <div>
                    <h4>📁 生成的文件清单</h4>
                    <ul style="font-family: monospace; font-size: 14px;">
                        <li>📄 calculator_enhanced.proto</li>
                        <li>🐍 calculator_server_enhanced.py</li>
                        <li>🐍 calculator_client_enhanced.py</li>
                        <li>📜 run_enhanced_demo.py</li>
                        <li>🧪 test_type_constraints.py</li>
                        <li>⚡ performance_test.py</li>
                        <li>📈 comparison_report.md</li>
                        <li>📋 best_practices.md</li>
                    </ul>
                </div>
                
                <div>
                    <h4>🚀 快速启动命令</h4>
                    <pre style="font-size: 12px;"><code># 一键启动完整演示
python run_enhanced_demo.py

# 运行类型约束测试
python test_type_constraints.py

# 性能测试对比
python performance_test.py</code></pre>
                </div>
            </div>

            <h4>🎯 强类型约束的核心价值</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                <div style="background: #1e7e34; color: white; padding: 15px; border-radius: 6px;">
                    <strong>开发安全性</strong><br>
                    编译时错误检查、IDE智能提示、重构安全保障
                </div>
                <div style="background: #007bff; color: white; padding: 15px; border-radius: 6px;">
                    <strong>运行时可靠性</strong><br>
                    多层验证机制、详细错误信息、优雅降级处理
                </div>
                <div style="background: #6610f2; color: white; padding: 15px; border-radius: 6px;">
                    <strong>维护便利性</strong><br>
                    向前兼容性、版本控制、自动化测试支持
                </div>
                <div style="background: #e83e8c; color: white; padding: 15px; border-radius: 6px;">
                    <strong>团队协作效率</strong><br>
                    清晰的接口定义、一致的错误处理、标准化开发流程
                </div>
            </div>
        </div>

        <div class="command-section">
            <h3>🏆 学习成果总结</h3>
            <p>通过这个完整的gRPC强类型约束演示，您将掌握：</p>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h4>🔧 技术技能</h4>
                    <ul>
                        <li>Protocol Buffers高级特性应用</li>
                        <li>gRPC服务设计模式</li>
                        <li>多层验证机制实现</li>
                        <li>类型安全的客户端设计</li>
                        <li>性能优化和监控</li>
                        <li>测试驱动开发</li>
                    </ul>
                </div>
                <div>
                    <h4>🎯 最佳实践</h4>
                    <ul>
                        <li>企业级错误处理策略</li>
                        <li>API版本演进管理</li>
                        <li>生产环境部署配置</li>
                        <li>可观测性和监控</li>
                        <li>安全和认证机制</li>
                        <li>团队协作流程</li>
                    </ul>
                </div>
            </div>
            
            <div style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 6px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #155724; margin: 0 0 10px 0;">💡 关键洞察</h4>
                <p style="color: #155724; margin: 0;">
                    <strong>类型约束不仅是技术选择，更是工程质量的体现。</strong>
                    通过投资强类型系统，我们获得的不仅是更少的bug，
                    更是更高的开发效率、更好的用户体验和更强的系统可维护性。
                    在企业级应用中，这种前期投资将在长期维护中获得巨大回报。
                </p>
            </div>
        </div>

        <div class="step">🛡️ 强类型约束的核心优势</div>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; margin: 20px 0;">
            <div class="file-section">
                <div class="file-header">
                    <span class="file-icon">🔒</span>
                    编译时类型安全
                </div>
                <div class="code-content">
                    <p><strong>Protocol Buffers层面：</strong></p>
                    <ul>
                        <li>枚举类型防止无效操作</li>
                        <li>oneof字段确保互斥性</li>
                        <li>必需字段验证</li>
                        <li>数据类型强制约束</li>
                    </ul>
                    <p><strong>客户端层面：</strong></p>
                    <ul>
                        <li>Python枚举类型安全</li>
                        <li>数据类型包装器</li>
                        <li>输入验证器</li>
                        <li>自动类型转换</li>
                    </ul>
                </div>
            </div>

            <div class="file-section">
                <div class="file-header">
                    <span class="file-icon">⚡</span>
                    运行时验证机制
                </div>
                <div class="code-content">
                    <p><strong>多层验证：</strong></p>
                    <ul>
                        <li>客户端预验证（早期错误发现）</li>
                        <li>服务端业务逻辑验证</li>
                        <li>数值范围检查</li>
                        <li>精度配置验证</li>
                    </ul>
                    <p><strong>错误处理：</strong></p>
                    <ul>
                        <li>结构化错误代码</li>
                        <li>详细错误信息</li>
                        <li>修复建议</li>
                        <li>上下文信息</li>
                    </ul>
                </div>
            </div>

            <div class="file-section">
                <div class="file-header">
                    <span class="file-icon">🎯</span>
                    业务逻辑约束
                </div>
                <div class="code-content">
                    <p><strong>数学运算约束：</strong></p>
                    <ul>
                        <li>除零检测</li>
                        <li>负数开方检测</li>
                        <li>数值溢出检测</li>
                        <li>精度损失检测</li>
                    </ul>
                    <p><strong>配置约束：</strong></p>
                    <ul>
                        <li>小数位数限制</li>
                        <li>超时时间验证</li>
                        <li>精度模式选择</li>
                        <li>数值范围限制</li>
                    </ul>
                </div>
            </div>

            <div class="file-section">
                <div class="file-header">
                    <span class="file-icon">🔧</span>
                    开发体验提升
                </div>
                <div class="code-content">
                    <p><strong>IDE支持：</strong></p>
                    <ul>
                        <li>代码自动补全</li>
                        <li>类型提示</li>
                        <li>编译时错误检查</li>
                        <li>重构安全性</li>
                    </ul>
                    <p><strong>维护性：</strong></p>
                    <ul>
                        <li>接口向前兼容</li>
                        <li>版本控制</li>
                        <li>文档自动生成</li>
                        <li>测试用例生成</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="command-section">
            <h3>🔍 类型约束对比演示</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h4>❌ 原始版本 (弱类型)</h4>
                    <pre><code># 字符串操作类型 - 容易出错
request.operation = "add"  # 拼写错误风险

# 简单数值 - 无验证
request.a = float("abc")  # 运行时错误

# 无结构化错误
success = False
message = "something wrong"</code></pre>
                </div>
                <div>
                    <h4>✅ 增强版本 (强类型)</h4>
                    <pre><code># 枚举类型 - 编译时安全
request.operation = Operation.ADD  # 类型安全

# 验证包装器 - 早期错误发现
validated_a = validator.validate_number("abc")

# 结构化错误 - 丰富信息
ErrorInfo(code=INVALID_INPUT, 
         message="详细错误", 
         suggestions=["修复建议"])</code></pre>
                </div>
            </div>
        </div>

        <div class="step">步骤 6: 强类型约束完整启动脚本</div>

        <div class="file-section">
            <div class="file-header">
                <span class="file-icon">📜</span>
                run_enhanced_demo.py - 强类型约束演示启动器
            </div>
            <div class="code-content">
                <pre><code><span class="keyword">import</span> subprocess
<span class="keyword">import</span> sys
<span class="keyword">import</span> time
<span class="keyword">import</span> threading
<span class="keyword">import</span> os
<span class="keyword">import</span> psutil
<span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor

<span class="keyword">def</span> <span class="function">create_enhanced_proto</span>():
    <span class="string">"""创建增强版proto文件"""</span>
    <span class="keyword">print</span>(<span class="string">"📄 创建增强版Protocol Buffer定义..."</span>)
    
    enhanced_proto = <span class="string">'''syntax = "proto3";

package calculator.v2;

import "google/protobuf/timestamp.proto";

// 操作类型枚举
enum OperationType {
    OPERATION_UNSPECIFIED = 0;
    OPERATION_ADD = 1;
    OPERATION_SUBTRACT = 2;
    OPERATION_MULTIPLY = 3;
    OPERATION_DIVIDE = 4;
    OPERATION_POWER = 5;
    OPERATION_SQRT = 6;
    OPERATION_MODULO = 7;
}

// 精度类型
enum Precision {
    PRECISION_STANDARD = 0;
    PRECISION_HIGH = 1;
    PRECISION_SCIENTIFIC = 2;
}

// 错误代码
enum ErrorCode {
    ERROR_NONE = 0;
    ERROR_DIVISION_BY_ZERO = 1;
    ERROR_INVALID_OPERATION = 2;
    ERROR_NUMBER_TOO_LARGE = 3;
    ERROR_NUMBER_TOO_SMALL = 4;
    ERROR_NEGATIVE_SQRT = 5;
    ERROR_OVERFLOW = 6;
    ERROR_UNDERFLOW = 7;
}

// 服务定义
service CalculatorV2 {
    rpc Calculate(CalculationRequest) returns (CalculationResponse);
    rpc BatchCalculate(BatchCalculationRequest) returns (BatchCalculationResponse);
    rpc StreamCalculate(stream CalculationRequest) returns (stream CalculationResponse);
    rpc GetCapabilities(CapabilitiesRequest) returns (CapabilitiesResponse);
    rpc ValidateExpression(ValidationRequest) returns (ValidationResponse);
}

// 计算请求
message CalculationRequest {
    oneof operand_a {
        double number_a = 1;
        string decimal_a = 2;
    }
    
    oneof operand_b {
        double number_b = 3;
        string decimal_b = 4;
    }
    
    OperationType operation = 5;
    CalculationConfig config = 6;
    RequestMetadata metadata = 7;
}

// 计算配置
message CalculationConfig {
    Precision precision = 1;
    int32 decimal_places = 2;
    bool use_scientific_notation = 3;
    double max_value = 4;
    double min_value = 5;
    int32 timeout_ms = 6;
}

// 请求元数据
message RequestMetadata {
    string request_id = 1;
    string client_id = 2;
    string client_version = 3;
    google.protobuf.Timestamp request_time = 4;
    int32 priority = 5;
}

// 计算响应
message CalculationResponse {
    oneof result {
        double number_result = 1;
        string decimal_result = 2;
        string scientific_result = 3;
    }
    
    bool success = 4;
    ErrorInfo error = 5;
    CalculationStats stats = 6;
    ResponseMetadata metadata = 7;
}

// 错误信息
message ErrorInfo {
    ErrorCode code = 1;
    string message = 2;
    string details = 3;
    string operation_context = 4;
    repeated string suggestions = 5;
}

// 统计信息
message CalculationStats {
    int64 execution_time_us = 1;
    int64 memory_used_bytes = 2;
    bool precision_lost = 3;
    int32 intermediate_steps = 4;
}

// 响应元数据
message ResponseMetadata {
    string request_id = 1;
    string server_id = 2;
    string server_version = 3;
    google.protobuf.Timestamp response_time = 4;
}

// 批量请求
message BatchCalculationRequest {
    repeated CalculationRequest requests = 1;
    bool fail_fast = 2;
    bool parallel_execution = 3;
    int32 max_concurrent = 4;
}

// 批量响应
message BatchCalculationResponse {
    repeated CalculationResponse responses = 1;
    int32 total_requests = 2;
    int32 successful_requests = 3;
    int32 failed_requests = 4;
    int64 total_execution_time_us = 5;
}

// 能力查询
message CapabilitiesRequest {}

message CapabilitiesResponse {
    repeated OperationType supported_operations = 1;
    repeated Precision supported_precisions = 2;
    double max_number = 3;
    double min_number = 4;
    int32 max_decimal_places = 5;
    int32 max_batch_size = 6;
    int32 max_concurrent_streams = 7;
    int32 default_timeout_ms = 8;
    string server_version = 9;
    string protocol_version = 10;
}

// 验证请求
message ValidationRequest {
    CalculationRequest request = 1;
    
    enum ValidationLevel {
        BASIC = 0;
        STRICT = 1;
        COMPLETE = 2;
    }
    
    ValidationLevel level = 2;
}

// 验证响应
message ValidationResponse {
    bool is_valid = 1;
    repeated string errors = 2;
    repeated string warnings = 3;
    repeated string suggestions = 4;
    int64 estimated_execution_time_us = 5;
    string expected_result_type = 6;
}'''</span>
    
    <span class="keyword">with</span> open(<span class="string">'calculator_enhanced.proto'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:
        f.write(enhanced_proto)
    
    <span class="keyword">print</span>(<span class="string">"✅ 增强版proto文件创建完成"</span>)

<span class="keyword">def</span> <span class="function">generate_enhanced_proto_code</span>():
    <span class="string">"""生成增强版Protocol Buffer代码"""</span>
    <span class="keyword">print</span>(<span class="string">"🔧 生成增强版gRPC代码..."</span>)
    
    <span class="keyword">try</span>:
        subprocess.run([
            sys.executable, <span class="string">'-m'</span>, <span class="string">'grpc_tools.protoc'</span>,
            <span class="string">'--proto_path=.'</span>,
            <span class="string">'--python_out=.'</span>,
            <span class="string">'--grpc_python_out=.'</span>,
            <span class="string">'calculator_enhanced.proto'</span>
        ], check=<span class="keyword">True</span>)
        <span class="keyword">print</span>(<span class="string">"✅ 增强版gRPC代码生成成功！"</span>)
        <span class="keyword">return</span> <span class="keyword">True</span>
    <span class="keyword">except</span> subprocess.CalledProcessError:
        <span class="keyword">print</span>(<span class="string">"❌ 增强版代码生成失败"</span>)
        <span class="keyword">return</span> <span class="keyword">False</span>

<span class="keyword">def</span> <span class="function">check_dependencies</span>():
    <span class="string">"""检查并安装依赖"""</span>
    <span class="keyword">print</span>(<span class="string">"📦 检查依赖包..."</span>)
    
    required_packages = [
        <span class="string">'grpcio'</span>, <span class="string">'grpcio-tools'</span>, <span class="string">'psutil'</span>
    ]
    missing_packages = []
    
    <span class="keyword">for</span> package <span class="keyword">in</span> required_packages:
        <span class="keyword">try</span>:
            __import__(package.replace(<span class="string">'-'</span>, <span class="string">'_'</span>))
        <span class="keyword">except</span> ImportError:
            missing_packages.append(package)
    
    <span class="keyword">if</span> missing_packages:
        <span class="keyword">print</span>(<span class="string">f"❌ 缺少依赖包: {', '.join(missing_packages)}"</span>)
        <span class="keyword">print</span>(<span class="string">"📥 正在安装缺少的依赖..."</span>)
        
        <span class="keyword">for</span> package <span class="keyword">in</span> missing_packages:
            <span class="keyword">try</span>:
                subprocess.run([sys.executable, <span class="string">'-m'</span>, <span class="string">'pip'</span>, <span class="string">'install'</span>, package], 
                             check=<span class="keyword">True</span>, capture_output=<span class="keyword">True</span>)
                <span class="keyword">print</span>(<span class="string">f"✅ {package} 安装成功"</span>)
            <span class="keyword">except</span> subprocess.CalledProcessError:
                <span class="keyword">print</span>(<span class="string">f"❌ {package} 安装失败"</span>)
                <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="keyword">print</span>(<span class="string">"✅ 所有依赖包已就绪"</span>)
    <span class="keyword">return</span> <span class="keyword">True</span>

<span class="keyword">def</span> <span class="function">run_performance_comparison</span>():
    <span class="string">"""运行性能对比测试"""</span>
    <span class="keyword">print</span>(<span class="string">"\n🏃 启动性能对比测试..."</span>)
    
    <span class="comment"># 性能测试脚本</span>
    perf_test_code = <span class="string">'''
import time
import grpc
import statistics
from concurrent.futures import ThreadPoolExecutor

# 假设已导入相关模块
try:
    import calculator_enhanced_pb2 as pb2
    import calculator_enhanced_pb2_grpc as pb2_grpc
    
    def performance_test():
        """性能测试函数"""
        print("🔥 执行性能测试...")
        
        # 连接到增强版服务器
        channel = grpc.insecure_channel('localhost:50052')
        stub = pb2_grpc.CalculatorV2Stub(channel)
        
        # 测试参数
        test_operations = [
            (100.5, 50.2, pb2.OPERATION_ADD),
            (1000.123, 7.89, pb2.OPERATION_MULTIPLY),
            (999.999, 3.333, pb2.OPERATION_DIVIDE),
            (16, 0, pb2.OPERATION_SQRT),
        ]
        
        results = []
        
        for a, b, op in test_operations:
            times = []
            
            # 运行多次测试
            for _ in range(10):
                request = pb2.CalculationRequest(
                    number_a=a,
                    number_b=b if op != pb2.OPERATION_SQRT else 0,
                    operation=op
                )
                
                start = time.perf_counter()
                response = stub.Calculate(request)
                end = time.perf_counter()
                
                if response.success:
                    times.append((end - start) * 1000)  # 转换为毫秒
            
            if times:
                avg_time = statistics.mean(times)
                results.append((op, avg_time, min(times), max(times)))
        
        # 打印结果
        print("\\n📊 性能测试结果:")
        print("操作类型\\t\\t平均时间(ms)\\t最小时间(ms)\\t最大时间(ms)")
        print("-" * 60)
        
        op_names = {
            pb2.OPERATION_ADD: "加法",
            pb2.OPERATION_MULTIPLY: "乘法", 
            pb2.OPERATION_DIVIDE: "除法",
            pb2.OPERATION_SQRT: "开方"
        }
        
        for op, avg, min_t, max_t in results:
            name = op_names.get(op, "未知")
            print(f"{name}\\t\\t{avg:.3f}\\t\\t{min_t:.3f}\\t\\t{max_t:.3f}")
        
        channel.close()
        print("✅ 性能测试完成")
        
    if __name__ == "__main__":
        performance_test()
        
except ImportError as e:
    print(f"❌ 导入模块失败: {e}")
    print("请确保增强版服务器正在运行")
'''</span>
    
    <span class="keyword">with</span> open(<span class="string">'performance_test.py'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:
        f.write(perf_test_code)
    
    <span class="keyword">print</span>(<span class="string">"✅ 性能测试脚本已创建"</span>)

<span class="keyword">def</span> <span class="function">run_enhanced_server</span>():
    <span class="string">"""运行增强版服务器"""</span>
    <span class="keyword">try</span>:
        <span class="keyword">import</span> calculator_server_enhanced
        calculator_server_enhanced.serve()
    <span class="keyword">except</span> ImportError:
        <span class="keyword">print</span>(<span class="string">"❌ 无法导入增强版服务器模块"</span>)
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        <span class="keyword">print</span>(<span class="string">f"❌ 服务器启动失败: {e}"</span>)

<span class="keyword">def</span> <span class="function">run_enhanced_client_demo</span>():
    <span class="string">"""运行增强版客户端演示"""</span>
    time.sleep(<span class="number">3</span>)  <span class="comment"># 等待服务器启动</span>
    
    <span class="keyword">try</span>:
        <span class="keyword">import</span> calculator_client_enhanced
        calculator_client_enhanced.demo_type_safety()
    <span class="keyword">except</span> ImportError:
        <span class="keyword">print</span>(<span class="string">"❌ 无法导入增强版客户端模块"</span>)
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        <span class="keyword">print</span>(<span class="string">f"❌ 客户端演示失败: {e}"</span>)

<span class="keyword">def</span> <span class="function">monitor_system_resources</span>():
    <span class="string">"""监控系统资源使用"""</span>
    <span class="keyword">print</span>(<span class="string">"📊 系统资源监控启动..."</span>)
    
    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">30</span>):  <span class="comment"># 监控30秒</span>
        cpu_percent = psutil.cpu_percent(interval=<span class="number">1</span>)
        memory = psutil.virtual_memory()
        
        <span class="keyword">if</span> cpu_percent > <span class="number">50</span> <span class="keyword">or</span> memory.percent > <span class="number">80</span>:
            <span class="keyword">print</span>(<span class="string">f"⚠️  高资源使用: CPU {cpu_percent}%, 内存 {memory.percent}%"</span>)
        
        time.sleep(<span class="number">1</span>)

<span class="keyword">def</span> <span class="function">create_comparison_report</span>():
    <span class="string">"""创建对比报告"""</span>
    <span class="keyword">print</span>(<span class="string">"📈 生成对比报告..."</span>)
    
    report = <span class="string">"""
# gRPC强类型约束vs基础版本对比报告

## 功能对比

| 特性 | 基础版本 | 强类型约束版本 |
|------|----------|----------------|
| 操作类型 | 字符串 | 枚举类型 |
| 数值输入 | 简单double | oneof多种格式 |
| 错误处理 | 简单布尔值 | 结构化错误信息 |
| 精度控制 | 固定精度 | 可配置精度 |
| 验证机制 | 服务端验证 | 多层验证 |
| 元数据 | 无 | 丰富的请求/响应元数据 |
| 统计信息 | 无 | 执行时间、内存使用等 |
| 服务发现 | 无 | 能力查询API |

## 类型安全优势

### 编译时安全
- ✅ 枚举类型防止拼写错误
- ✅ oneof字段确保数据一致性
- ✅ 强类型检查

### 运行时验证
- ✅ 多层输入验证
- ✅ 业务逻辑约束检查
- ✅ 详细错误信息和修复建议

### 开发体验
- ✅ IDE智能提示
- ✅ 代码重构安全
- ✅ 自动化测试支持

## 性能影响

类型约束带来的额外开销：
- Protocol Buffer序列化: +5-10%
- 验证逻辑: +2-5%
- 元数据处理: +1-3%

总体性能影响: 5-20% (可接受范围内)

## 建议

### 适用场景
- ✅ 企业级应用
- ✅ 关键业务系统
- ✅ 多团队协作项目
- ✅ 长期维护项目

### 不适用场景
- ❌ 简单内部工具
- ❌ 原型验证
- ❌ 极端性能要求场景

## 结论

强类型约束版本虽然增加了一定复杂度，但在企业级应用中
带来的类型安全、维护性和可靠性提升远超额外成本。
"""</span>
    
    <span class="keyword">with</span> open(<span class="string">'comparison_report.md'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:
        f.write(report)
    
    <span class="keyword">print</span>(<span class="string">"✅ 对比报告已生成: comparison_report.md"</span>)

<span class="keyword">def</span> <span class="function">main</span>():
    <span class="string">"""主函数 - 强类型约束演示启动器"""</span>
    <span class="keyword">print</span>(<span class="string">"🚀 gRPC强类型约束演示启动中..."</span>)
    <span class="keyword">print</span>(<span class="string">"=" * 60</span>)
    
    <span class="comment"># 1. 检查依赖</span>
    <span class="keyword">if</span> <span class="keyword">not</span> check_dependencies():
        <span class="keyword">print</span>(<span class="string">"❌ 依赖检查失败，退出"</span>)
        <span class="keyword">return</span>
    
    <span class="comment"># 2. 创建增强版proto文件</span>
    create_enhanced_proto()
    
    <span class="comment"># 3. 生成代码</span>
    <span class="keyword">if</span> <span class="keyword">not</span> generate_enhanced_proto_code():
        <span class="keyword">print</span>(<span class="string">"❌ 代码生成失败，退出"</span>)
        <span class="keyword">return</span>
    
    <span class="comment"># 4. 创建性能测试脚本</span>
    run_performance_comparison()
    
    <span class="comment"># 5. 创建对比报告</span>
    create_comparison_report()
    
    <span class="comment"># 6. 使用线程池启动所有组件</span>
    <span class="keyword">print</span>(<span class="string">"\n🔥 启动强类型约束演示..."</span>)
    
    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:
        <span class="comment"># 启动服务器</span>
        server_future = executor.submit(run_enhanced_server)
        
        <span class="comment"># 启动资源监控</span>
        monitor_future = executor.submit(monitor_system_resources)
        
        <span class="comment"># 启动客户端演示</span>
        client_future = executor.submit(run_enhanced_client_demo)
        
        <span class="keyword">print</span>(<span class="string">"✅ 所有组件已启动"</span>)
        <span class="keyword">print</span>(<span class="string">"📝 查看生成的文件:"</span>)
        <span class="keyword">print</span>(<span class="string">"   - calculator_enhanced.proto (协议定义)"</span>)
        <span class="keyword">print</span>(<span class="string">"   - performance_test.py (性能测试)"</span>)
        <span class="keyword">print</span>(<span class="string">"   - comparison_report.md (对比报告)"</span>)
        <span class="keyword">print</span>(<span class="string">"\n🎮 按 Ctrl+C 停止演示"</span>)
        
        <span class="keyword">try</span>:
            <span class="comment"># 等待用户中断</span>
            client_future.result(<span class="number">60</span>)  <span class="comment"># 最多等待60秒</span>
        <span class="keyword">except</span> KeyboardInterrupt:
            <span class="keyword">print</span>(<span class="string">"\n👋 用户中断，正在停止..."</span>)
        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
            <span class="keyword">print</span>(<span class="string">f"\n❌ 演示过程出错: {e}"</span>)
        <span class="keyword">finally</span>:
            <span class="keyword">print</span>(<span class="string">"🏁 强类型约束演示结束"</span>)

<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:
    main()
</code></pre>
            </div>
        </div>

        <div class="step">步骤 7: 类型约束测试套件</div>

        <div class="file-section">
            <div class="file-header">
                <span class="file-icon">🧪</span>
                test_type_constraints.py - 类型约束测试套件
            </div>
            <div class="code-content">
                <pre><code><span class="keyword">import</span> unittest
<span class="keyword">import</span> grpc
<span class="keyword">import</span> time
<span class="keyword">import</span> threading
<span class="keyword">from</span> unittest.mock <span class="keyword">import</span> patch, MagicMock

<span class="keyword">try</span>:
    <span class="keyword">import</span> calculator_enhanced_pb2 <span class="keyword">as</span> pb2
    <span class="keyword">import</span> calculator_enhanced_pb2_grpc <span class="keyword">as</span> pb2_grpc
    <span class="keyword">from</span> calculator_client_enhanced <span class="keyword">import</span> (
        EnhancedCalculatorClient, Operation, PrecisionType,
        CalculationConfig, InputValidator
    )
    <span class="keyword">from</span> calculator_server_enhanced <span class="keyword">import</span> (
        EnhancedCalculatorServicer, TypeValidator, PrecisionCalculator
    )
<span class="keyword">except</span> ImportError <span class="keyword">as</span> e:
    <span class="keyword">print</span>(<span class="string">f"⚠️  导入模块失败: {e}"</span>)
    <span class="keyword">print</span>(<span class="string">"请先运行 run_enhanced_demo.py 生成必要的代码"</span>)
    exit(<span class="number">1</span>)

<span class="keyword">class</span> <span class="function">TestTypeConstraints</span>(unittest.TestCase):
    <span class="string">"""类型约束测试套件"""</span>
    
    <span class="keyword">def</span> <span class="function">setUp</span>(<span class="keyword">self</span>):
        <span class="string">"""测试前准备"""</span>
        <span class="keyword">self</span>.servicer = EnhancedCalculatorServicer()
        <span class="keyword">self</span>.client = EnhancedCalculatorClient()
    
    <span class="keyword">def</span> <span class="function">test_operation_type_enum_validation</span>(<span class="keyword">self</span>):
        <span class="string">"""测试操作类型枚举验证"""</span>
        <span class="keyword">print</span>(<span class="string">"🧪 测试操作类型枚举验证..."</span>)
        
        <span class="comment"># 测试有效的操作类型</span>
        valid_ops = [
            pb2.OPERATION_ADD, pb2.OPERATION_SUBTRACT,
            pb2.OPERATION_MULTIPLY, pb2.OPERATION_DIVIDE,
            pb2.OPERATION_POWER, pb2.OPERATION_SQRT, pb2.OPERATION_MODULO
        ]
        
        <span class="keyword">for</span> op <span class="keyword">in</span> valid_ops:
            is_valid, error = TypeValidator.validate_operation_type(op)
            <span class="keyword">self</span>.assertTrue(is_valid, <span class="string">f"操作 {op} 应该是有效的"</span>)
            <span class="keyword">self</span>.assertEqual(error, <span class="string">""</span>)
        
        <span class="comment"># 测试无效的操作类型</span>
        is_valid, error = TypeValidator.validate_operation_type(pb2.OPERATION_UNSPECIFIED)
        <span class="keyword">self</span>.assertFalse(is_valid)
        <span class="keyword">self</span>.assertIn(<span class="string">"操作类型未指定"</span>, error)
        
        <span class="keyword">print</span>(<span class="string">"✅ 操作类型枚举验证测试通过"</span>)
    
    <span class="keyword">def</span> <span class="function">test_numeric_value_validation</span>(<span class="keyword">self</span>):
        <span class="string">"""测试数值验证"""</span>
        <span class="keyword">print</span>(<span class="string">"🧪 测试数值验证..."</span>)
        
        <span class="comment"># 测试有效数值</span>
        valid_numbers = [<span class="number">0</span>, <span class="number">42</span>, <span class="number">-100</span>, <span class="number">3.14159</span>, <span class="number">1e10</span>]
        <span class="keyword">for</span> num <span class="keyword">in</span> valid_numbers:
            is_valid, error = TypeValidator.validate_numeric_value(num)
            <span class="keyword">self</span>.assertTrue(is_valid, <span class="string">f"数值 {num} 应该是有效的"</span>)
        
        <span class="comment"># 测试无效数值</span>
        <span class="keyword">import</span> math
        invalid_numbers = [<span class="keyword">float</span>(<span class="string">'nan'</span>), <span class="keyword">float</span>(<span class="string">'inf'</span>), <span class="number">1e16</span>]
        <span class="keyword">for</span> num <span class="keyword">in</span> invalid_numbers:
            is_valid, error = TypeValidator.validate_numeric_value(num)
            <span class="keyword">self</span>.assertFalse(is_valid, <span class="string">f"数值 {num} 应该是无效的"</span>)
            <span class="keyword">self</span>.assertNotEqual(error, <span class="string">""</span>)
        
        <span class="keyword">print</span>(<span class="string">"✅ 数值验证测试通过"</span>)
    
    <span class="keyword">def</span> <span class="function">test_client_input_validation</span>(<span class="keyword">self</span>):
        <span class="string">"""测试客户端输入验证"""</span>
        <span class="keyword">print</span>(<span class="string">"🧪 测试客户端输入验证..."</span>)
        
        <span class="comment"># 测试数值验证</span>
        valid_inputs = [<span class="number">42</span>, <span class="number">3.14</span>, <span class="string">"123.456"</span>]
        <span class="keyword">for</span> inp <span class="keyword">in</span> valid_inputs:
            result = InputValidator.validate_number(inp, <span class="string">"测试"</span>)
            <span class="keyword">self</span>.assertIsInstance(result, <span class="keyword">float</span>)
        
        <span class="comment"># 测试无效输入</span>
        invalid_inputs = [<span class="string">"abc"</span>, <span class="string">""</span>, <span class="keyword">None</span>, <span class="number">1e16</span>]
        <span class="keyword">for</span> inp <span class="keyword">in</span> invalid_inputs:
            <span class="keyword">with</span> <span class="keyword">self</span>.assertRaises((TypeError, ValueError)):
                InputValidator.validate_number(inp, <span class="string">"测试"</span>)
        
        <span class="comment"># 测试操作类型验证</span>
        valid_operations = [Operation.ADD, <span class="string">"MULTIPLY"</span>, <span class="string">"divide"</span>]
        <span class="keyword">for</span> op <span class="keyword">in</span> valid_operations:
            result = InputValidator.validate_operation(op)
            <span class="keyword">self</span>.assertIsInstance(result, Operation)
        
        <span class="comment"># 测试无效操作</span>
        <span class="keyword">with</span> <span class="keyword">self</span>.assertRaises(ValueError):
            InputValidator.validate_operation(<span class="string">"INVALID_OP"</span>)
        
        <span class="keyword">print</span>(<span class="string">"✅ 客户端输入验证测试通过"</span>)
    
    <span class="keyword">def</span> <span class="function">test_precision_calculation</span>(<span class="keyword">self</span>):
        <span class="string">"""测试精度计算"""</span>
        <span class="keyword">print</span>(<span class="string">"🧪 测试精度计算..."</span>)
        
        <span class="comment"># 创建测试请求</span>
        request = pb2.CalculationRequest(
            number_a=<span class="number">123.456789</span>,
            number_b=<span class="number">987.654321</span>,
            operation=pb2.OPERATION_ADD
        )
        
        <span class="comment"># 提取数值</span>
        a, b = PrecisionCalculator.get_numeric_value(request)
        <span class="keyword">self</span>.assertEqual(a, <span class="number">123.456789</span>)
        <span class="keyword">self</span>.assertEqual(b, <span class="number">987.654321</span>)
        
        <span class="comment"># 测试高精度格式</span>
        request_decimal = pb2.CalculationRequest(
            decimal_a=<span class="string">"123.456789012345"</span>,
            decimal_b=<span class="string">"987.654321098765"</span>,
            operation=pb2.OPERATION_MULTIPLY
        )
        
        a_dec, b_dec = PrecisionCalculator.get_numeric_value(request_decimal)
        <span class="keyword">self</span>.assertAlmostEqual(a_dec, <span class="number">123.456789012345</span>, places=<span class="number">10</span>)
        
        <span class="comment"># 测试结果格式化</span>
        config = pb2.CalculationConfig(
            precision=pb2.PRECISION_HIGH,
            decimal_places=<span class="number">4</span>,
            use_scientific_notation=<span class="keyword">False</span>
        )
        
        number_result, decimal_result, scientific_result = PrecisionCalculator.format_result(<span class="number">123.456789</span>, config)
        <span class="keyword">self</span>.assertEqual(decimal_result, <span class="string">"123.4568"</span>)
        
        <span class="keyword">print</span>(<span class="string">"✅ 精度计算测试通过"</span>)
    
    <span class="keyword">def</span> <span class="function">test_error_handling</span>(<span class="keyword">self</span>):
        <span class="string">"""测试错误处理"""</span>
        <span class="keyword">print</span>(<span class="string">"🧪 测试错误处理..."</span>)
        
        <span class="comment"># 模拟gRPC上下文</span>
        context = MagicMock()
        
        <span class="comment"># 测试除零错误</span>
        request = pb2.CalculationRequest(
            number_a=<span class="number">10</span>,
            number_b=<span class="number">0</span>,
            operation=pb2.OPERATION_DIVIDE
        )
        
        response = <span class="keyword">self</span>.servicer.Calculate(request, context)
        <span class="keyword">self</span>.assertFalse(response.success)
        <span class="keyword">self</span>.assertEqual(response.error.code, pb2.ERROR_DIVISION_BY_ZERO)
        <span class="keyword">self</span>.assertIn(<span class="string">"除数不能为零"</span>, response.error.message)
        <span class="keyword">self</span>.assertGreater(<span class="keyword">len</span>(response.error.suggestions), <span class="number">0</span>)
        
        <span class="comment"># 测试负数开方错误</span>
        request_sqrt = pb2.CalculationRequest(
            number_a=<span class="number">-4</span>,
            operation=pb2.OPERATION_SQRT
        )
        
        response_sqrt = <span class="keyword">self</span>.servicer.Calculate(request_sqrt, context)
        <span class="keyword">self</span>.assertFalse(response_sqrt.success)
        <span class="keyword">self</span>.assertEqual(response_sqrt.error.code, pb2.ERROR_NEGATIVE_SQRT)
        
        <span class="comment"># 测试无效操作类型</span>
        request_invalid = pb2.CalculationRequest(
            number_a=<span class="number">10</span>,
            number_b=<span class="number">5</span>,
            operation=pb2.OPERATION_UNSPECIFIED
        )
        
        response_invalid = <span class="keyword">self</span>.servicer.Calculate(request_invalid, context)
        <span class="keyword">self</span>.assertFalse(response_invalid.success)
        <span class="keyword">self</span>.assertEqual(response_invalid.error.code, pb2.ERROR_INVALID_OPERATION)
        
        <span class="keyword">print</span>(<span class="string">"✅ 错误处理测试通过"</span>)
    
    <span class="keyword">def</span> <span class="function">test_server_capabilities</span>(<span class="keyword">self</span>):
        <span class="string">"""测试服务器能力查询"""</span>
        <span class="keyword">print</span>(<span class="string">"🧪 测试服务器能力查询..."</span>)
        
        context = MagicMock()
        request = pb2.CapabilitiesRequest()
        
        response = <span class="keyword">self</span>.servicer.GetCapabilities(request, context)
        
        <span class="comment"># 验证支持的操作</span>
        <span class="keyword">self</span>.assertIn(pb2.OPERATION_ADD, response.supported_operations)
        <span class="keyword">self</span>.assertIn(pb2.OPERATION_SQRT, response.supported_operations)
        
        <span class="comment"># 验证精度类型</span>
        <span class="keyword">self</span>.assertIn(pb2.PRECISION_STANDARD, response.supported_precisions)
        <span class="keyword">self</span>.assertIn(pb2.PRECISION_HIGH, response.supported_precisions)
        
        <span class="comment"># 验证数值限制</span>
        <span class="keyword">self</span>.assertGreater(response.max_number, <span class="number">0</span>)
        <span class="keyword">self</span>.assertLess(response.min_number, <span class="number">0</span>)
        <span class="keyword">self</span>.assertGreater(response.max_decimal_places, <span class="number">0</span>)
        
        <span class="comment"># 验证版本信息</span>
        <span class="keyword">self</span>.assertIsNotNone(response.server_version)
        <span class="keyword">self</span>.assertIsNotNone(response.protocol_version)
        
        <span class="keyword">print</span>(<span class="string">"✅ 服务器能力查询测试通过"</span>)
    
    <span class="keyword">def</span> <span class="function">test_validation_request</span>(<span class="keyword">self</span>):
        <span class="string">"""测试表达式验证"""</span>
        <span class="keyword">print</span>(<span class="string">"🧪 测试表达式验证..."</span>)
        
        context = MagicMock()
        
        <span class="comment"># 测试有效表达式</span>
        calc_request = pb2.CalculationRequest(
            number_a=<span class="number">10</span>,
            number_b=<span class="number">5</span>,
            operation=pb2.OPERATION_ADD
        )
        
        validation_request = pb2.ValidationRequest(
            request=calc_request,
            level=pb2.ValidationRequest.COMPLETE
        )
        
        response = <span class="keyword">self</span>.servicer.ValidateExpression(validation_request, context)
        <span class="keyword">self</span>.assertTrue(response.is_valid)
        <span class="keyword">self</span>.assertEqual(<span class="keyword">len</span>(response.errors), <span class="number">0</span>)
        <span class="keyword">self</span>.assertGreater(response.estimated_execution_time_us, <span class="number">0</span>)
        
        <span class="comment"># 测试无效表达式</span>
        invalid_calc_request = pb2.CalculationRequest(
            number_a=<span class="number">10</span>,
            number_b=<span class="number">0</span>,
            operation=pb2.OPERATION_DIVIDE
        )
        
        invalid_validation_request = pb2.ValidationRequest(
            request=invalid_calc_request,
            level=pb2.ValidationRequest.COMPLETE
        )
        
        invalid_response = <span class="keyword">self</span>.servicer.ValidateExpression(invalid_validation_request, context)
        <span class="keyword">self</span>.assertFalse(invalid_response.is_valid)
        <span class="keyword">self</span>.assertGreater(<span class="keyword">len</span>(invalid_response.errors), <span class="number">0</span>)
        
        <span class="keyword">print</span>(<span class="string">"✅ 表达式验证测试通过"</span>)

<span class="keyword">class</span> <span class="function">TestIntegration</span>(unittest.TestCase):
    <span class="string">"""集成测试"""</span>
    
    <span class="keyword">def</span> <span class="function">test_end_to_end_calculation</span>(<span class="keyword">self</span>):
        <span class="string">"""测试端到端计算流程"""</span>
        <span class="keyword">print</span>(<span class="string">"🧪 测试端到端计算流程..."</span>)
        
        <span class="comment"># 模拟完整的客户端-服务端交互</span>
        servicer = EnhancedCalculatorServicer()
        context = MagicMock()
        
        <span class="comment"># 测试各种计算类型</span>
        test_cases = [
            (<span class="number">10</span>, <span class="number">5</span>, pb2.OPERATION_ADD, <span class="number">15</span>),
            (<span class="number">20</span>, <span class="number">4</span>, pb2.OPERATION_DIVIDE, <span class="number">5</span>),
            (<span class="number">3</span>, <span class="number">4</span>, pb2.OPERATION_POWER, <span class="number">81</span>),
            (<span class="number">16</span>, <span class="number">0</span>, pb2.OPERATION_SQRT, <span class="number">4</span>),
        ]
        
        <span class="keyword">for</span> a, b, operation, expected <span class="keyword">in</span> test_cases:
            request = pb2.CalculationRequest(
                number_a=a,
                number_b=b <span class="keyword">if</span> operation != pb2.OPERATION_SQRT <span class="keyword">else</span> <span class="number">0</span>,
                operation=operation,
                metadata=pb2.RequestMetadata(
                    request_id=<span class="string">f"test-{operation}"</span>,
                    client_id=<span class="string">"unittest"</span>
                )
            )
            
            response = servicer.Calculate(request, context)
            
            <span class="keyword">self</span>.assertTrue(response.success, <span class="string">f"计算失败: {response.error.message}"</span>)
            <span class="keyword">self</span>.assertAlmostEqual(response.number_result, expected, places=<span class="number">5</span>)
            <span class="keyword">self</span>.assertIsNotNone(response.stats)
            <span class="keyword">self</span>.assertIsNotNone(response.metadata)
        
        <span class="keyword">print</span>(<span class="string">"✅ 端到端计算流程测试通过"</span>)

<span class="keyword">def</span> <span class="function">run_test_suite</span>():
    <span class="string">"""运行完整测试套件"""</span>
    <span class="keyword">print</span>(<span class="string">"🧪 开始运行类型约束测试套件..."</span>)
    <span class="keyword">print</span>(<span class="string">"=" * 60</span>)
    
    <span class="comment"># 创建测试套件</span>
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    <span class="comment"># 添加测试类</span>
    suite.addTests(loader.loadTestsFromTestCase(TestTypeConstraints))
    suite.addTests(loader.loadTestsFromTestCase(TestIntegration))
    
    <span class="comment"># 运行测试</span>
    runner = unittest.TextTestRunner(verbosity=<span class="number">2</span>)
    result = runner.run(suite)
    
    <span class="comment"># 输出结果</span>
    <span class="keyword">print</span>(<span class="string">"=" * 60</span>)
    <span class="keyword">if</span> result.wasSuccessful():
        <span class="keyword">print</span>(<span class="string">"🎉 所有测试通过！类型约束系统工作正常"</span>)
    <span class="keyword">else</span>:
        <span class="keyword">print</span>(<span class="string">f"❌ 测试失败: {<span class="keyword">len</span>(result.failures)} 个失败, {<span class="keyword">len</span>(result.errors)} 个错误"</span>)
        
        <span class="keyword">for</span> test, error <span class="keyword">in</span> result.failures:
            <span class="keyword">print</span>(<span class="string">f"失败: {test} - {error}"</span>)
        
        <span class="keyword">for</span> test, error <span class="keyword">in</span> result.errors:
            <span class="keyword">print</span>(<span class="string">f"错误: {test} - {error}"</span>)
    
    <span class="keyword">return</span> result.wasSuccessful()

<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:
    success = run_test_suite()
    exit(<span class="number">0</span> <span class="keyword">if</span> success <span class="keyword">else</span> <span class="number">1</span>)
</code></pre>
            </div>
        </div>
    </div>
</body>
</html>
